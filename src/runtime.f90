  
 USE ISO_C_BINDING, ONLY: C_PTR,C_LOC,C_F_POINTER
 USE MPI
 IMPLICIT INTEGER(KIND=MPI_ADDRESS_KIND)(I,N),INTEGER (J),LOGICAL(L),TYPE(PM__QBUFFER) (Q)
 IMPLICIT TYPE(PM__LBUFFER) (R),TYPE(PM__ZBUFFER) (Z),INTEGER(MPI_OFFSET_KIND) (O),TYPE(PM__WBUFFER) (W)

 INTEGER,PARAMETER:: PM__MAX_FILENAME_SIZE=1024
 
 INTEGER,PARAMETER:: PM__LN=MPI_ADDRESS_KIND
 INTEGER,PARAMETER:: PM__LLN=MPI_OFFSET_KIND
 INTEGER,PARAMETER:: PM__D=KIND(0.0D0)

 INTEGER*1 PM__I8_EXAMPLE
 INTEGER*2 PM__I16_EXAMPLE
 INTEGER*4 PM__I32_EXAMPLE
 INTEGER*8 PM__I64_EXAMPLE

 INTEGER,PARAMETER:: PM__I8=KIND(PM__I8_EXAMPLE)
 INTEGER,PARAMETER:: PM__I16=KIND(PM__I16_EXAMPLE)
 INTEGER,PARAMETER:: PM__I32=KIND(PM__I32_EXAMPLE)
 INTEGER,PARAMETER:: PM__I64=KIND(PM__I64_EXAMPLE)
 
!> call out_types
 
 INTEGER,PARAMETER:: PM__INT=6
 INTEGER,PARAMETER:: PM__LONG=7
 INTEGER,PARAMETER:: PM__LONGLONG=8
 INTEGER,PARAMETER:: PM__INT8=9
 INTEGER,PARAMETER:: PM__INT16=10  
 INTEGER,PARAMETER:: PM__INT32=11
 INTEGER,PARAMETER:: PM__INT64=12
 INTEGER,PARAMETER:: PM__INT128=13
 INTEGER,PARAMETER:: PM__SINGLE=14
 INTEGER,PARAMETER:: PM__DOUBLE=15
 INTEGER,PARAMETER:: PM__REAL32=16
 INTEGER,PARAMETER:: PM__REAL64=17
 INTEGER,PARAMETER:: PM__REAL128=18
 INTEGER,PARAMETER:: PM__SINGLE_COMPLEX=19
 INTEGER,PARAMETER:: PM__DOUBLE_COMPLEX=20
 INTEGER,PARAMETER:: PM__COMPLEX64=21
 INTEGER,PARAMETER:: PM__COMPLEX128=22  
 INTEGER,PARAMETER:: PM__COMPLEX256=23
 INTEGER,PARAMETER:: PM__LOGICAL=24
 INTEGER,PARAMETER:: PM__PACKED_LOGICAL=25
 INTEGER,PARAMETER:: PM__EXT=26
 INTEGER,PARAMETER:: PM__STRING=27
 
 TYPE PM__LBUFFER
    INTEGER(PM__LN),DIMENSION(:),ALLOCATABLE:: P
 END TYPE PM__LBUFFER
 
 TYPE PM__QBUFFER
    INTEGER(PM__LN),DIMENSION(1):: P
 END TYPE PM__QBUFFER

 TYPE PM__WBUFFER
    INTEGER,DIMENSION(:),ALLOCATABLE:: P
 END type PM__WBUFFER
 
 TYPE PM__ZBUFFER
    INTEGER,DIMENSION(7):: P
 END TYPE PM__ZBUFFER

 TYPE PM__STR
    CHARACTER(LEN=1),DIMENSION(:),ALLOCATABLE:: P
 END TYPE PM__STR
 
 TYPE PM__POLY
    CLASS(*),ALLOCATABLE:: P
 END TYPE PM__POLY

 ! WRAPPER TYPES FOR POLYMORPHIC INSTANCES OF BASIC VALUES
 
 TYPE PM__TI
    INTEGER:: P
 END type PM__TI

 TYPE PM__TLN
    INTEGER(PM__LN):: P
 END type PM__TLN

 TYPE PM__TLLN
    INTEGER(PM__LLN):: P
 END type PM__TLLN

 TYPE PM__TI8
    INTEGER(PM__I8):: P
 END type PM__TI8
 
 TYPE PM__TI16
    INTEGER(PM__I16):: P
 END type PM__TI16

 TYPE PM__TI32
    INTEGER(PM__I32):: P
 END type PM__TI32

 TYPE PM__TI64
    INTEGER(PM__I64):: P
 END type PM__TI64
 
 TYPE PM__TR
    REAL:: P
 END type PM__TR

 TYPE PM__TD
    DOUBLE PRECISION:: P
 END TYPE PM__TD

 TYPE PM__TC
    COMPLEX:: P
 END type PM__TC

 TYPE PM__TDC
    COMPLEX(PM__D):: P
 END type PM__TDC

 TYPE PM__TL
    LOGICAL:: P
 END TYPE PM__TL
 
 ! STACK ENTRY WITH DETAILS OF (POSSIBLY NESTED) PARALLEL STATEMENT
 TYPE PM__NODE_INFO_FRAME
    INTEGER:: THIS_NODE          ! RANK IN COMMUNCATING GROUP
    INTEGER:: THIS_NNODE         ! NUM PROCS IN COMMUNICATING GROUP 
    INTEGER:: THIS_COMM         ! MPI COMMUNICATOR FOR COMM. GROUP.
    INTEGER:: ROOT_NODE          ! ROOT OF SHARED GROUP (AS RANK IN THIS_COMM)
    INTEGER:: SHARED_NODE        ! RANK IN SHARED GROUP
                                ! (RUNNING THE SAME INVOCATION)
    INTEGER:: SHARED_NNODE       ! NUMBER OF PROCESSES IN SHARED GROUP
    INTEGER:: SHARED_COMM       ! MPI COMMUNICATOR FOR SHARED GROUP
    LOGICAL:: IS_SHARED         ! PROCESS IS PART OF GROUP, SOME OF WHICH SHARE
 END TYPE PM__NODE_INFO_FRAME
 
 ! TEMPORARY BUFFERS FOR MESSAGES
 TYPE PM__MBUFFER
    TYPE(PM__MBUFFER),POINTER:: NEXT
    INTEGER(PM__LN),DIMENSION(PM__INT:PM__STRING):: SIZEOF
    INTEGER,DIMENSION(:),ALLOCATABLE:: I
    INTEGER(PM__I8),DIMENSION(:),ALLOCATABLE:: I8
    INTEGER(PM__I16),DIMENSION(:),ALLOCATABLE:: I16
    INTEGER(PM__I32),DIMENSION(:),ALLOCATABLE:: I32
    INTEGER(PM__I64),DIMENSION(:),ALLOCATABLE:: I64
    INTEGER(PM__LN),DIMENSION(:),ALLOCATABLE:: LN
    REAL,DIMENSION(:),ALLOCATABLE:: R
    REAL(PM__D),DIMENSION(:),ALLOCATABLE:: D
    COMPLEX,DIMENSION(:),ALLOCATABLE:: C
    COMPLEX(PM__D),DIMENSION(:),ALLOCATABLE:: DC
    LOGICAL,DIMENSION(:),ALLOCATABLE:: L
 END TYPE PM__MBUFFER
 
 ! STACK OF PM__NODE_INFO_FRAME STRUCTURES
 INTEGER,PARAMETER:: PM__MAX_NODE_DEPTH=128
 TYPE(PM__NODE_INFO_FRAME),DIMENSION(PM__MAX_NODE_DEPTH):: PM__NODE_FRAME
 INTEGER:: PM__NODE_DEPTH
 
 ! MAXIMUM MESSAGE SIZES
 INTEGER,PARAMETER:: PM__MAX_MESSAGE_SIZE=(HUGE(1)/2)+1
 INTEGER,PARAMETER:: PM__EXCHANGE_BLOCK= 16*1024 !*1024
 INTEGER,PARAMETER:: PM__NODE_BLOCK = 64
 
 ! STATUS OF AN MPI NODE
 INTEGER:: PM__CONC_DEPTH
 INTEGER:: PM__SYS_NODE,PM__SYS_NNODE   ! RANK IN MPI_COMM_WORLD
 
 ! STACKS OF PENDING MESSAGES
 INTEGER,PARAMETER:: PM__MAX_MESSAGES=1024
 INTEGER,DIMENSION(:),ALLOCATABLE:: PM__MESSAGE_STACK
 INTEGER:: PM__MESSAGE_TOP
 INTEGER:: PM__MESSAGE_STACK_SIZE
 TYPE(PM__MBUFFER),POINTER:: PM__BUFFER

 INTEGER,DIMENSION(MPI_STATUS_SIZE):: PM__STAT
 
 ! DATA TAGS
 INTEGER,PARAMETER:: PM__REQ_TAG=1
 INTEGER,PARAMETER:: PM__REQ_TAG2=2
 INTEGER,PARAMETER:: PM__DATA_TAG=3
 INTEGER,PARAMETER:: PM__EXTRA_TAG=4
 INTEGER,PARAMETER:: PM__HDR_TAG=5
 INTEGER,PARAMETER:: PM__EXTRA_REQ_TAG=6
 INTEGER,PARAMETER:: PM__EXTRA_REQ_EXTRA_TAG=7

 ! ALTERNATING REQUEST TAGS
 INTEGER:: PM__REQUEST=PM__REQ_TAG

 ! MPI TYPES
 INTEGER,DIMENSION(:),ALLOCATABLE:: PM__MPI_TYPES

 CALL PM__INIT_PAR

 CALL PM__MAKE_MPI_TYPES
 
 CALL PM__P0

 CALL PM__FINALISE_PAR
 
CONTAINS

!> call gen_procs
  
 PURE FUNCTION PM__STRVAL(C) RESULT(S)
   CHARACTER(LEN=*),INTENT(IN):: C
   TYPE(PM__STR):: S
   INTEGER(PM__LN):: I,N
   N=LEN(C,KIND=PM__LN)
   ALLOCATE(S%P(N))
   DO I=1,N
      S%P(I)=C(I:I)
   ENDDO
 END FUNCTION PM__STRVAL

 PURE FUNCTION PM__CONCAT_STR(S1,S2) RESULT(S)
   TYPE(PM__STR),INTENT(IN):: S1,S2
   TYPE(PM__STR):: S
   INTEGER(PM__LN):: I,N1,N2
   N1=SIZE(S1%P,KIND=PM__LN)
   N2=SIZE(S2%P,KIND=PM__LN)
   ALLOCATE(S%P(N1+N2))
   DO I=1,N1
      S%P(I)=S1%P(I)
   ENDDO
   DO I=1,N2
       S%P(I+N1)=S2%P(I)
    ENDDO
 END FUNCTION PM__CONCAT_STR
  
 PURE FUNCTION PM__INT_TO_STR(I) RESULT(S)
   INTEGER,INTENT(IN):: I
   TYPE(PM__STR):: S
   CHARACTER(LEN=16):: BUFFER
   WRITE(BUFFER,'(I10)') I
   S=PM__STRVAL(TRIM(ADJUSTL(BUFFER)))
 END FUNCTION PM__INT_TO_STR

 PURE FUNCTION PM__LONG_TO_STR(I) RESULT(S)
   INTEGER(PM__LN),INTENT(IN):: I
   TYPE(PM__STR):: S
   CHARACTER(LEN=24):: BUFFER
   WRITE(BUFFER,'(I20)') I
   S=PM__STRVAL(TRIM(ADJUSTL(BUFFER)))
 END FUNCTION PM__LONG_TO_STR

 PURE FUNCTION PM__OFFSET_TO_STR(I) RESULT(S)
   INTEGER(PM__LLN),INTENT(IN):: I
   TYPE(PM__STR):: S
   CHARACTER(LEN=34):: BUFFER
   WRITE(BUFFER,'(I30)') I
   S=PM__STRVAL(TRIM(ADJUSTL(BUFFER)))
 END FUNCTION PM__OFFSET_TO_STR

 PURE FUNCTION PM__INT64_TO_STR(I) RESULT(S)
   INTEGER(PM__I64),INTENT(IN):: I
   TYPE(PM__STR):: S
   CHARACTER(LEN=24):: BUFFER
   WRITE(BUFFER,'(I20)') I
   S=PM__STRVAL(TRIM(ADJUSTL(BUFFER)))
 END FUNCTION PM__INT64_TO_STR

 PURE FUNCTION PM__REAL_TO_STR(R) RESULT(S)
   REAL,INTENT(IN):: R
   TYPE(PM__STR):: S
   CHARACTER(LEN=16):: BUFFER
   WRITE(BUFFER,'(G15.8)') R
   S=PM__STRVAL(TRIM(ADJUSTL(BUFFER)))
 END FUNCTION PM__REAL_TO_STR
 
 PURE FUNCTION PM__DOUBLE_TO_STR(R) RESULT(S)
   DOUBLE PRECISION,INTENT(IN):: R
   TYPE(PM__STR):: S
   CHARACTER(LEN=32):: BUFFER
   WRITE(BUFFER,'(G25.15)') R
   S=PM__STRVAL(TRIM(ADJUSTL(BUFFER)))
 END FUNCTION PM__DOUBLE_TO_STR
 
 PURE FUNCTION PM__BOOL_TO_STR(B) RESULT(S)
   LOGICAL,INTENT(IN):: B
   TYPE(PM__STR):: S
   IF(B) THEN
      S=PM__STRVAL('TRUE')
   ELSE
      S=PM__STRVAL('FALSE')
   ENDIF
 END FUNCTION PM__BOOL_TO_STR

 FUNCTION PM__BOXI(X) RESULT(P)
   INTEGER:: X
   TYPE(PM__TI)::P
   P%P=X
 END FUNCTION PM__BOXI

 FUNCTION PM__BOXLN(X) RESULT(P)
   INTEGER(PM__LN):: X
   TYPE(PM__TLN)::P
   P%P=X
 END FUNCTION PM__BOXLN

 FUNCTION PM__BOXLLN(X) RESULT(P)
   INTEGER(PM__LLN):: X
   TYPE(PM__TLLN)::P
   P%P=X
 END FUNCTION PM__BOXLLN

 FUNCTION PM__BOXI8(X) RESULT(P)
   INTEGER(PM__I8):: X
   TYPE(PM__TI8)::P
   P%P=X
 END FUNCTION PM__BOXI8

 FUNCTION PM__BOXI16(X) RESULT(P)
   INTEGER(PM__I16):: X
   TYPE(PM__TI16)::P
   P%P=X
 END FUNCTION PM__BOXI16

 FUNCTION PM__BOXI32(X) RESULT(P)
   INTEGER(PM__I32):: X
   TYPE(PM__TI32)::P
   P%P=X
 END FUNCTION PM__BOXI32
 
 FUNCTION PM__BOXI64(X) RESULT(P)
   INTEGER(PM__I64):: X
   TYPE(PM__TI64)::P
   P%P=X
 END FUNCTION PM__BOXI64

 FUNCTION PM__BOXR(X) RESULT(P)
   REAL:: X
   TYPE(PM__TR)::P
   P%P=X
 END FUNCTION PM__BOXR

 FUNCTION PM__BOXD(X) RESULT(P)
   DOUBLE PRECISION:: X
   TYPE(PM__TD)::P
   P%P=X
 END FUNCTION PM__BOXD

 FUNCTION PM__BOXC(X) RESULT(P)
   COMPLEX:: X
   TYPE(PM__TC)::P
   P%P=X
 END FUNCTION PM__BOXC

 FUNCTION PM__BOXDC(X) RESULT(P)
   COMPLEX(PM__D):: X
   TYPE(PM__TDC)::P
   P%P=X
 END FUNCTION PM__BOXDC
 
 FUNCTION PM__BOXL(X) RESULT(P)
   LOGICAL:: X
   TYPE(PM__TL)::P
   P%P=X
 END FUNCTION PM__BOXL
 
 SUBROUTINE PM__PRINT(S)
   TYPE(PM__STR):: S
   IF(PM__NODE_FRAME(PM__NODE_DEPTH)%ROOT_NODE==PM__NODE_FRAME(PM__NODE_DEPTH)%THIS_NODE) THEN
      WRITE(*,*) S%P
   ENDIF
 END SUBROUTINE  PM__PRINT
 
 SUBROUTINE PM__CHECK(S,L)
   TYPE(PM__STR):: S
   LOGICAL:: L
   IF(.NOT.L) CALL PM__PRINT(S)
 END SUBROUTINE PM__CHECK
 
 ! INITIALISE PM MPI SUBSYSTEM
 SUBROUTINE PM__INIT_PAR()
   INTEGER:: ERROR
   CALL MPI_INIT(ERROR)
   PM__NODE_DEPTH=1
   CALL MPI_COMM_SIZE(MPI_COMM_WORLD,PM__SYS_NNODE,ERROR)
   CALL MPI_COMM_RANK(MPI_COMM_WORLD,PM__SYS_NODE,ERROR)
   PM__NODE_FRAME(PM__NODE_DEPTH)%THIS_NNODE=PM__SYS_NNODE
   PM__NODE_FRAME(PM__NODE_DEPTH)%THIS_NODE=PM__SYS_NODE
   PM__NODE_FRAME(PM__NODE_DEPTH)%ROOT_NODE=0
   PM__NODE_FRAME(PM__NODE_DEPTH)%THIS_COMM=MPI_COMM_WORLD
   PM__NODE_FRAME(PM__NODE_DEPTH)%SHARED_COMM=MPI_COMM_WORLD
   PM__NODE_FRAME(PM__NODE_DEPTH)%SHARED_NODE=PM__NODE_FRAME(PM__NODE_DEPTH)%THIS_NODE
   PM__NODE_FRAME(PM__NODE_DEPTH)%SHARED_NNODE=PM__NODE_FRAME(PM__NODE_DEPTH)%THIS_NNODE
   PM__CONC_DEPTH=0
   PM__MESSAGE_TOP=0
   PM__MESSAGE_STACK_SIZE=PM__MAX_MESSAGES
   ALLOCATE(PM__MESSAGE_STACK(PM__MAX_MESSAGES))
   NULLIFY(PM__BUFFER)
 END SUBROUTINE PM__INIT_PAR
 
 ! FINALISE MPI SUBSYSTEM
 SUBROUTINE PM__FINALISE_PAR()
   INTEGER:: ERROR
   CALL MPI_FINALIZE(ERROR)
 END SUBROUTINE PM__FINALISE_PAR
 
 ! CREATE A NEW COMMUNICATING GROUP USING MPI SPLIT
 SUBROUTINE PM__PUSH_NODE_SPLIT(ROOT) 
   INTEGER(PM__LN),INTENT(IN):: ROOT
   INTEGER:: ERROR,NEWCOMM
   INTEGER:: THIS_COMM
   THIS_COMM=PM__NODE_FRAME(PM__NODE_DEPTH)%THIS_COMM
   CALL MPI_COMM_SPLIT(THIS_COMM,INT(ROOT),PM__NODE_FRAME(PM__NODE_DEPTH)%THIS_NODE,&
        NEWCOMM,ERROR)
   PM__NODE_DEPTH=PM__NODE_DEPTH+1
   PM__NODE_FRAME(PM__NODE_DEPTH)%ROOT_NODE=ROOT
   PM__NODE_FRAME(PM__NODE_DEPTH)%THIS_NODE=PM__NODE_FRAME(PM__NODE_DEPTH-1)%SHARED_NODE
   PM__NODE_FRAME(PM__NODE_DEPTH)%THIS_NNODE=PM__NODE_FRAME(PM__NODE_DEPTH-1)%SHARED_NNODE
   PM__NODE_FRAME(PM__NODE_DEPTH)%THIS_COMM=PM__NODE_FRAME(PM__NODE_DEPTH-1)%SHARED_COMM
   PM__NODE_FRAME(PM__NODE_DEPTH)%IS_SHARED=.TRUE.
   CALL MPI_COMM_SIZE(NEWCOMM,PM__NODE_FRAME(PM__NODE_DEPTH)%SHARED_NNODE,ERROR)
   CALL MPI_COMM_RANK(NEWCOMM,PM__NODE_FRAME(PM__NODE_DEPTH)%SHARED_NODE,ERROR)
   PM__NODE_FRAME(PM__NODE_DEPTH)%SHARED_COMM=NEWCOMM
 END SUBROUTINE PM__PUSH_NODE_SPLIT
 
 ! NEW FRAME USED FORMER SHARED COMMUNICATOR
 SUBROUTINE PM__PUSH_NODE_DISTR()
   PM__NODE_DEPTH=PM__NODE_DEPTH+1
   PM__NODE_FRAME(PM__NODE_DEPTH)%THIS_NODE=PM__NODE_FRAME(PM__NODE_DEPTH-1)%SHARED_NODE
   PM__NODE_FRAME(PM__NODE_DEPTH)%ROOT_NODE=PM__NODE_FRAME(PM__NODE_DEPTH-1)%SHARED_NODE
   PM__NODE_FRAME(PM__NODE_DEPTH)%THIS_NNODE=PM__NODE_FRAME(PM__NODE_DEPTH-1)%SHARED_NNODE
   PM__NODE_FRAME(PM__NODE_DEPTH)%THIS_COMM=PM__NODE_FRAME(PM__NODE_DEPTH-1)%SHARED_COMM
   PM__NODE_FRAME(PM__NODE_DEPTH)%SHARED_COMM=MPI_COMM_SELF
   PM__NODE_FRAME(PM__NODE_DEPTH)%SHARED_NNODE=1
   PM__NODE_FRAME(PM__NODE_DEPTH)%SHARED_NODE=0
   PM__NODE_FRAME(PM__NODE_DEPTH)%IS_SHARED=.FALSE.
 END SUBROUTINE PM__PUSH_NODE_DISTR
 
 ! POP COMMUNICATING GROUP - REVERT TO NEXT OUTER LAYER
 SUBROUTINE PM__POP_NODE()
   INTEGER:: ERROR,OLD_SHARED,OLD_THIS
   IF(PM__CONC_DEPTH>0) THEN
      PM__CONC_DEPTH=PM__CONC_DEPTH-1
   ELSE
      OLD_SHARED=PM__NODE_FRAME(PM__NODE_DEPTH)%SHARED_COMM
      OLD_THIS=PM__NODE_FRAME(PM__NODE_DEPTH)%THIS_COMM
      PM__NODE_DEPTH=PM__NODE_DEPTH-1
      IF(OLD_THIS/=MPI_COMM_SELF.AND.&
           PM__NODE_FRAME(PM__NODE_DEPTH)%SHARED_COMM/=OLD_THIS) THEN
         CALL MPI_COMM_FREE(OLD_THIS,ERROR)
      ENDIF
      IF(OLD_SHARED/=MPI_COMM_SELF) THEN
         CALL MPI_COMM_FREE(OLD_SHARED,ERROR)
      ENDIF
   ENDIF
 END SUBROUTINE PM__POP_NODE

 FUNCTION PM__GET_SHARED(I) RESULT(NODE)
   INTEGER,INTENT(IN):: I
   INTEGER:: NODE
   INTEGER:: GROUP_S,GROUP_T,ERROR
   INTEGER,DIMENSION(1):: IN,OUT
   CALL MPI_COMM_GROUP(PM__NODE_FRAME(PM__NODE_DEPTH)%SHARED_COMM,GROUP_S,ERROR)
   CALL MPI_COMM_GROUP(PM__NODE_FRAME(PM__NODE_DEPTH)%THIS_COMM,GROUP_T,ERROR)
   IN(1)=I
   CALL MPI_GROUP_TRANSLATE_RANKS(GROUP_S,1,IN,GROUP_T,OUT,ERROR)
   NODE=OUT(1)
 END FUNCTION PM__GET_SHARED
 
 SUBROUTINE PM__GROW_STACK(STACK,STACK_SIZE,NEW_STACK_SIZE)
   INTEGER,DIMENSION(:),ALLOCATABLE,INTENT(INOUT):: STACK
   INTEGER,INTENT(INOUT):: STACK_SIZE
   INTEGER,INTENT(IN):: NEW_STACK_SIZE
   INTEGER,DIMENSION(:),ALLOCATABLE:: TEMP
   ALLOCATE(TEMP(STACK_SIZE))
   CALL MOVE_ALLOC(STACK,TEMP)
   ALLOCATE(STACK(NEW_STACK_SIZE))
   STACK(1:STACK_SIZE)=TEMP
   STACK_SIZE=NEW_STACK_SIZE
   DEALLOCATE(TEMP)
 END SUBROUTINE PM__GROW_STACK
 
 SUBROUTINE PM__GET_MPI_TYPE(TNO,N,MPI_TYP,M,LNEW)
   INTEGER,INTENT(IN):: TNO
   INTEGER(PM__LN),INTENT(IN)::N
   INTEGER,INTENT(OUT):: MPI_TYP
   INTEGER,INTENT(OUT):: M
   LOGICAL,INTENT(OUT):: LNEW
   INTEGER:: NEWTYP,K,ERRNO
   INTEGER(PM__LN),DIMENSION(2):: DISPL
   INTEGER,DIMENSION(2):: TYP,BLK
   IF(N<=PM__MAX_MESSAGE_SIZE) THEN
      MPI_TYP=TNO
      M=N
      LNEW=.FALSE.
      RETURN
   ELSE
      CALL MPI_TYPE_CONTIGUOUS(PM__MAX_MESSAGE_SIZE,TNO,NEWTYP,ERRNO)
      BLK(2)=N/PM__MAX_MESSAGE_SIZE
      BLK(1)=N-BLK(2)*PM__MAX_MESSAGE_SIZE
      TYP(2)=NEWTYP
      TYP(1)=TNO
      CALL MPI_TYPE_SIZE(TYP(1),K,ERRNO)
      DISPL(2)=INT(K,PM__LN)*BLK(1)
      DISPL(1)=0
      CALL MPI_TYPE_CREATE_STRUCT(2,BLK,DISPL,TYP,MPI_TYP,ERRNO)
      CALL MPI_TYPE_COMMIT(MPI_TYP,ERRNO)
      M=1
      LNEW=.TRUE.
   ENDIF
 END SUBROUTINE PM__GET_MPI_TYPE
 
 FUNCTION PM__GET_MPI_MASKED_TYPE(TNO,MASK,NMASK,M) RESULT(MPI_TYP)
   INTEGER,INTENT(IN):: TNO
   INTEGER(PM__LN),INTENT(IN):: NMASK,M
   LOGICAL,INTENT(IN),DIMENSION(NMASK):: MASK
   INTEGER:: MPI_TYP
   INTEGER(PM__LN),DIMENSION(:),ALLOCATABLE:: V
   INTEGER(PM__LN):: I,J,N
   N=COUNT(MASK)
   ALLOCATE(V(N))
   J=0
   DO I=1,SIZE(MASK)
      IF(MASK(I)) THEN
         J=J+1
         V(J)=I
      ENDIF
   ENDDO
   CALL PM__GET_MPI_DISP_TYPE(TNO,V,M,MPI_TYP)
 END FUNCTION PM__GET_MPI_MASKED_TYPE
  
 ! MAKE A TYPE FROM A SET OF VECTOR OFFSETS
 RECURSIVE SUBROUTINE PM__GET_MPI_DISP_TYPE(TNO,OFF,M,MPI_TYP)
   INTEGER,INTENT(IN):: TNO
   INTEGER(PM__LN),DIMENSION(:),INTENT(IN):: OFF
   INTEGER(PM__LN),INTENT(IN):: M
   INTEGER,INTENT(OUT):: MPI_TYP
   INTEGER:: ERRNO,N
   INTEGER(PM__LN):: START,END,I,NOFF
   INTEGER(PM__LN),ALLOCATABLE,DIMENSION(:):: DISPS
   INTEGER,ALLOCATABLE,DIMENSION(:):: LENS,TYPES
   NOFF=SIZE(OFF)
   IF(NOFF>PM__MAX_MESSAGE_SIZE) THEN
      N=(NOFF+PM__MAX_MESSAGE_SIZE-1)/PM__MAX_MESSAGE_SIZE
      ALLOCATE(DISPS(N),LENS(N),TYPES(N))
      DISPS=0
      LENS=1
      DO I=1,N
         START=(N-1)*PM__MAX_MESSAGE_SIZE+1+1
         END=MIN(NOFF,N*PM__MAX_MESSAGE_SIZE)+1
         CALL PM__GET_MPI_DISP_UNIT_TYPE(TNO,OFF(START:&
           END),M,TYPES(I))
      ENDDO
      CALL MPI_TYPE_CREATE_STRUCT(N,LENS,DISPS,TYPES,MPI_TYP,ERRNO)
      DO I=1,N
         CALL MPI_TYPE_FREE(TYPES(I),ERRNO)
      ENDDO
      DEALLOCATE(DISPS,LENS,TYPES)
   ELSE
      CALL PM__GET_MPI_DISP_UNIT_TYPE(TNO,OFF,M,MPI_TYP)
   ENDIF
   CALL MPI_TYPE_COMMIT(MPI_TYP,ERRNO)
 END SUBROUTINE PM__GET_MPI_DISP_TYPE
 
 RECURSIVE SUBROUTINE PM__GET_MPI_DISP_UNIT_TYPE(TNO,OFF,M,MPI_TYP)
   INTEGER,INTENT(IN):: TNO
   INTEGER(PM__LN),DIMENSION(:),INTENT(IN):: OFF
   INTEGER(PM__LN),INTENT(IN):: M
   INTEGER,INTENT(OUT):: MPI_TYP
   INTEGER:: M2,TNO2,SIZ,ERRNO,NOFF
   INTEGER(PM__LN),ALLOCATABLE,DIMENSION(:):: DISPS
   LOGICAL:: LNEW
   NOFF=SIZE(OFF)
   CALL MPI_TYPE_SIZE(TNO,SIZ,ERRNO)
   DISPS=OFF*(SIZ*M)
   IF(M<=PM__MAX_MESSAGE_SIZE) THEN
      CALL MPI_TYPE_CREATE_HINDEXED_BLOCK(NOFF,INT(M),DISPS,&
           TNO,MPI_TYP,ERRNO)
   ELSE
      CALL PM__GET_MPI_TYPE(TNO,M,TNO2,M2,LNEW)
      CALL MPI_TYPE_CREATE_HINDEXED_BLOCK(NOFF,M2,DISPS,&
           TNO2,MPI_TYP,ERRNO)
      IF(LNEW) CALL MPI_TYPE_FREE(TNO2,ERRNO)
   ENDIF
   DEALLOCATE(DISPS)
 END SUBROUTINE PM__GET_MPI_DISP_UNIT_TYPE

 ! CREATE MPI TYPE FOR SUBRANGE (START..END BY STEP [WIDTH,ALIGN]) OF (0..GSIZE)
 SUBROUTINE PM__GET_MPI_SUBRANGE_TYPE(TNO,GSIZE,START,END,STEP,WIDTH,ALIGN,TNO2)
   INTEGER,INTENT(IN):: TNO
   INTEGER(PM__LN),INTENT(IN):: GSIZE,START,END,STEP,WIDTH,ALIGN
   INTEGER,INTENT(OUT):: TNO2
   INTEGER(PM__LN):: N
   INTEGER(MPI_COUNT_KIND):: LB,SIZ
   INTEGER(MPI_ADDRESS_KIND):: DISPL(3)
   INTEGER:: BLK(3),MTYPES(3),ERRNO,M,TNO3
   !write(*,*) '#',TNO,GSIZE,START,'..',END,STEP,WIDTH,ALIGN
   CALL MPI_TYPE_GET_EXTENT_X(TNO,LB,SIZ,ERRNO)
   N=(END-START)/STEP+1
   IF(WIDTH>1.AND.(ALIGN>0.OR.START+(N-1)*STEP+WIDTH>END)) THEN
      ! PARTIAL BLOCK AT START OR END COMPLICATES THINGS...
      CALL PM__GET_MPI_CONTIG_TYPE(TNO, MAX(0_PM__LN,WIDTH-ALIGN),MTYPES(1),BLK(1))
      CALL PM__GET_MPI_STRIDED_BLOCK_TYPE(TNO,MAX(0_PM__LN,N-2),STEP,WIDTH,MTYPES(2),BLK(2))
      CALL PM__GET_MPI_CONTIG_TYPE(TNO, MIN(WIDTH,END-(START-ALIGN+(N-1)*STEP)),MTYPES(3),BLK(3))
      DISPL(1)=START*SIZ
      DISPL(2)=(START-ALIGN+STEP)*SIZ
      DISPL(3)=(START-ALIGN+(N-1)*STEP)*SIZ
      CALL MPI_TYPE_CREATE_STRUCT(3,BLK,DISPL,MTYPES,TNO3,ERRNO)
   ELSE
      CALL PM__GET_MPI_STRIDED_BLOCK_TYPE(TNO,N,STEP,WIDTH,TNO2,M)
      DISPL(1)=START*SIZ
      CALL MPI_TYPE_CREATE_HINDEXED_BLOCK(1,M,DISPL,TNO2,TNO3,ERRNO)
   ENDIF
   CALL MPI_TYPE_CREATE_RESIZED(TNO3,&
         INT(0,MPI_ADDRESS_KIND),INT(GSIZE*SIZ,MPI_ADDRESS_KIND),&
         TNO2,ERRNO)
 END SUBROUTINE PM__GET_MPI_SUBRANGE_TYPE

 ! CREATE AN MPI TYPE FOR 0..STEP*N BY STEP WITH GIVEN WIDTH
 SUBROUTINE PM__GET_MPI_STRIDED_BLOCK_TYPE(TNO,N,STEP,WIDTH,TNO2,COUNT)
   INTEGER,INTENT(IN):: TNO
   INTEGER(PM__LN),INTENT(IN):: N,STEP,WIDTH
   INTEGER,INTENT(OUT):: TNO2,COUNT
   INTEGER(MPI_COUNT_KIND):: LB,SIZ
   INTEGER(MPI_ADDRESS_KIND):: DISPL(2)
   INTEGER:: MTYPES(2),BLK(2)
   INTEGER:: TNO3,ERRNO,M
   !write(*,*) '>', TNO,N,'>>',STEP,'>>',WIDTH
   IF(N==0) THEN
      TNO2=TNO
   ELSEIF(STEP==1.AND.WIDTH==1) THEN
      CALL PM__GET_MPI_CONTIG_TYPE(TNO,N,TNO2,COUNT)
   ELSEIF(N<PM__MAX_MESSAGE_SIZE.AND.ABS(STEP)<PM__MAX_MESSAGE_SIZE.AND.WIDTH<PM__MAX_MESSAGE_SIZE) THEN
      CALL MPI_TYPE_VECTOR(INT(N),INT(WIDTH),INT(STEP),TNO,TNO2,ERRNO)
   ELSE
      ! AT LEAST SOMETHING IS LARGER THAN PM__MAX_MESSAGE_SIZE
      ! CONTRUCT BY HAND
      
      ! FIRST CREATE A BLOCK OF SIZE WIDTH
      CALL PM__GET_MPI_CONTIG_TYPE(TNO,WIDTH,TNO3)
      
      ! THE EXTEND EXTENT OF THIS TYPE TO STEP
      IF(ABS(STEP)>1) THEN
         CALL MPI_TYPE_GET_EXTENT_X(TNO,LB,SIZ,ERRNO)
         CALL MPI_TYPE_CREATE_RESIZED(TNO3,&
              INT(0,MPI_ADDRESS_KIND),INT(ABS(STEP)*SIZ,MPI_ADDRESS_KIND),&
              TNO2,ERRNO)
      ELSE
         TNO2=TNO3
      ENDIF
      
      ! NOW REPEAT N TIMES - BACKWARDS IS NECESSARY
      IF(STEP>0) THEN
         ! POSITIVE STEP - JUST REPEAT TYPE
         CALL PM__GET_MPI_CONTIG_TYPE(TNO2,N,TNO3,COUNT)
         TNO2=TNO3
      ELSEIF(N>PM__MAX_MESSAGE_SIZE) THEN
         ! NEGATIVE STEP AND LONG SIZE...
         CALL MPI_TYPE_GET_EXTENT_X(TNO2,LB,SIZ,ERRNO)
         CALL MPI_TYPE_VECTOR(PM__MAX_MESSAGE_SIZE,1,-1,TNO2,TNO3,ERRNO)
         M=N/PM__MAX_MESSAGE_SIZE
         CALL MPI_TYPE_VECTOR(M,1,-1,TNO3,MTYPES(2),ERRNO)
         M=N-PM__MAX_MESSAGE_SIZE*M
         CALL MPI_TYPE_VECTOR(M,1,-1,TNO2,MTYPES(1),ERRNO)
         DISPL(1)=0
         DISPL(2)=-M*SIZ
         BLK(1)=1
         BLK(2)=1
         CALL MPI_TYPE_CREATE_STRUCT(2,BLK,DISPL,MTYPES,TNO2,ERRNO)
      ELSE
         ! NEGATIVE STEP
         CALL MPI_TYPE_VECTOR(INT(N),1,-1,TNO,TNO2,ERRNO)
      ENDIF
   ENDIF
 END SUBROUTINE PM__GET_MPI_STRIDED_BLOCK_TYPE
 
 ! MPI TYPE - REPEAT N TIMES
 ! (OPTIONALLY CREATE SMALLER TYPE TO REPEAT COUNT TIMES
 ! WHERE COUNT IS STANDARD INT)
 SUBROUTINE PM__GET_MPI_CONTIG_TYPE(TNO,N,TNO2,COUNT)
   INTEGER,INTENT(IN):: TNO
   INTEGER(PM__LN),INTENT(IN):: N
   INTEGER,INTENT(OUT):: TNO2
   INTEGER,INTENT(OUT),OPTIONAL:: COUNT
   INTEGER(MPI_ADDRESS_KIND):: DISPL(2)
   INTEGER(MPI_COUNT_KIND):: LB,SIZ
   INTEGER:: MTYPES(2),BLK(2),ERRNO
   IF(N<=1) THEN
      TNO2=TNO
      IF(PRESENT(COUNT)) COUNT=N
   ELSEIF(N>PM__MAX_MESSAGE_SIZE) THEN
      CALL MPI_TYPE_CONTIGUOUS(PM__MAX_MESSAGE_SIZE,TNO,TNO2,ERRNO)
      CALL MPI_TYPE_GET_EXTENT_X(TNO2,LB,SIZ,ERRNO)
      MTYPES(1)=TNO
      MTYPES(2)=TNO2
      BLK(2)=N/PM__MAX_MESSAGE_SIZE
      BLK(1)=N-BLK(2)*PM__MAX_MESSAGE_SIZE
      DISPL(1)=0
      DISPL(2)=SIZ*BLK(1)
      CALL MPI_TYPE_CREATE_STRUCT(2,BLK,DISPL,MTYPES,TNO2,ERRNO)
      IF(PRESENT(COUNT)) COUNT=1
   ELSEIF(.NOT.PRESENT(COUNT)) THEN
      CALL MPI_TYPE_CONTIGUOUS(INT(N),TNO,TNO2,ERRNO)
   ELSE
      TNO2=TNO
      COUNT=N
   ENDIF
 END SUBROUTINE PM__GET_MPI_CONTIG_TYPE
  
 
 SUBROUTINE PM__PUSH_MESSAGE(MESS)
   INTEGER,INTENT(IN):: MESS
   PM__MESSAGE_TOP=PM__MESSAGE_TOP+1
   IF(PM__MESSAGE_TOP>=PM__MESSAGE_STACK_SIZE) THEN
      CALL PM__GROW_STACK(PM__MESSAGE_STACK,PM__MESSAGE_STACK_SIZE,PM__MESSAGE_STACK_SIZE*2)
   ENDIF
   PM__MESSAGE_STACK(PM__MESSAGE_TOP)=MESS
 END SUBROUTINE PM__PUSH_MESSAGE
 
 SUBROUTINE PM__COMPLETE_MESSAGES()
   INTEGER,DIMENSION(PM__MAX_MESSAGES):: STATUS
   INTEGER:: ERRNO,I,RQ,ISTAT(MPI_STATUS_SIZE)
   INTEGER(PM__LN):: J
   CALL MPI_WAITALL(PM__MESSAGE_TOP,PM__MESSAGE_STACK,&
        MPI_STATUSES_IGNORE,ERRNO)
   CALL PM__TIDY_MESSAGES()
 END SUBROUTINE PM__COMPLETE_MESSAGES
 
 SUBROUTINE PM__TIDY_MESSAGES()
   INTEGER:: I,ERRNO
   TYPE(PM__MBUFFER),POINTER::P
   IF(PM__MESSAGE_STACK_SIZE>PM__MAX_MESSAGES) THEN
      DEALLOCATE(PM__MESSAGE_STACK)
      ALLOCATE(PM__MESSAGE_STACK(PM__MAX_MESSAGES))
      PM__MESSAGE_STACK_SIZE=PM__MAX_MESSAGES
   ENDIF
   PM__MESSAGE_TOP=0
   CALL PM__FREE_BUFFERS
 END SUBROUTINE PM__TIDY_MESSAGES
 
 SUBROUTINE PM__NEW_BUFFER() 
   TYPE(PM__MBUFFER),POINTER:: P
   ALLOCATE(P)
   P%NEXT=>PM__BUFFER
   P%SIZEOF=0
   PM__BUFFER=>P
 END SUBROUTINE PM__NEW_BUFFER
 
 SUBROUTINE PM__POP_BUFFER()
   TYPE(PM__MBUFFER),POINTER:: P
   P=>PM__BUFFER
   PM__BUFFER=>P%NEXT
   DEALLOCATE(P)
 END SUBROUTINE PM__POP_BUFFER

 SUBROUTINE PM__FREE_BUFFERS()
   TYPE(PM__MBUFFER),POINTER:: P
   DO WHILE(ASSOCIATED(PM__BUFFER))
      P=>PM__BUFFER%NEXT
      DEALLOCATE(PM__BUFFER)
      PM__BUFFER=>P
   ENDDO
   NULLIFY(PM__BUFFER)
 END SUBROUTINE PM__FREE_BUFFERS

 SUBROUTINE PM__ALLOCATE_BUFFER
   IF(PM__BUFFER%SIZEOF(PM__INT).GT.0) ALLOCATE(PM__BUFFER%I(PM__BUFFER%SIZEOF(PM__INT)))
   IF(PM__BUFFER%SIZEOF(PM__INT8).GT.0) ALLOCATE(PM__BUFFER%I8(PM__BUFFER%SIZEOF(PM__INT8)))
   IF(PM__BUFFER%SIZEOF(PM__INT16).GT.0) ALLOCATE(PM__BUFFER%I16(PM__BUFFER%SIZEOF(PM__INT16)))
   IF(PM__BUFFER%SIZEOF(PM__INT32).GT.0) ALLOCATE(PM__BUFFER%I32(PM__BUFFER%SIZEOF(PM__INT32)))
   IF(PM__BUFFER%SIZEOF(PM__INT64).GT.0) ALLOCATE(PM__BUFFER%I64(PM__BUFFER%SIZEOF(PM__INT64)))
   IF(PM__BUFFER%SIZEOF(PM__LONG).GT.0) ALLOCATE(PM__BUFFER%LN(PM__BUFFER%SIZEOF(PM__LONG)))
   IF(PM__BUFFER%SIZEOF(PM__SINGLE).GT.0) ALLOCATE(PM__BUFFER%R(PM__BUFFER%SIZEOF(PM__SINGLE)))
   IF(PM__BUFFER%SIZEOF(PM__DOUBLE).GT.0) ALLOCATE(PM__BUFFER%D(PM__BUFFER%SIZEOF(PM__DOUBLE)))
   IF(PM__BUFFER%SIZEOF(PM__SINGLE_COMPLEX).GT.0) ALLOCATE(PM__BUFFER%C(PM__BUFFER%SIZEOF(PM__SINGLE_COMPLEX)))
   IF(PM__BUFFER%SIZEOF(PM__DOUBLE_COMPLEX).GT.0) ALLOCATE(PM__BUFFER%DC(PM__BUFFER%SIZEOF(PM__DOUBLE_COMPLEX)))
   IF(PM__BUFFER%SIZEOF(PM__LOGICAL).GT.0) ALLOCATE(PM__BUFFER%L(PM__BUFFER%SIZEOF(PM__LOGICAL)))
   PM__BUFFER%SIZEOF=0
 END SUBROUTINE PM__ALLOCATE_BUFFER
 
 SUBROUTINE PM__ISEND_BUFFER(NODE,ATAG,COMM)
   INTEGER,INTENT(IN):: NODE
   INTEGER,INTENT(IN):: ATAG,COMM
   INTEGER:: MESS,ERRNO,TNO,M,TAG
   LOGICAL:: MUST_FREE
   TAG=ATAG+1
   !write(*,*) 'sending buffer:',pm__buffer%sizeof
   CALL MPI_ISEND(PM__BUFFER%SIZEOF,PM__STRING-PM__INT+1,MPI_AINT,INT(NODE),TAG,COMM,MESS,ERRNO)
   CALL PM__PUSH_MESSAGE(MESS)
   IF(PM__BUFFER%SIZEOF(PM__INT).GT.0) THEN
      CALL PM__GET_MPI_TYPE(MPI_INTEGER,PM__BUFFER%SIZEOF(PM__INT),TNO,M,MUST_FREE)
      CALL MPI_ISEND(PM__BUFFER%I,M,TNO,INT(NODE),TAG,COMM,MESS,ERRNO)
      IF(MUST_FREE) CALL MPI_TYPE_FREE(TNO,ERRNO)
      CALL PM__PUSH_MESSAGE(MESS)
   END IF
   IF(PM__BUFFER%SIZEOF(PM__INT8).GT.0) THEN
      CALL PM__GET_MPI_TYPE(MPI_INTEGER1,PM__BUFFER%SIZEOF(PM__INT8),TNO,M,MUST_FREE)
      CALL MPI_ISEND(PM__BUFFER%I8,M,TNO,INT(NODE),TAG,COMM,MESS,ERRNO)
      IF(MUST_FREE) CALL MPI_TYPE_FREE(TNO,ERRNO)
      CALL PM__PUSH_MESSAGE(MESS)
   END IF
   IF(PM__BUFFER%SIZEOF(PM__INT16).GT.0) THEN
      CALL PM__GET_MPI_TYPE(MPI_INTEGER2,PM__BUFFER%SIZEOF(PM__INT16),TNO,M,MUST_FREE)
      CALL MPI_ISEND(PM__BUFFER%I16,M,TNO,INT(NODE),TAG,COMM,MESS,ERRNO)
      IF(MUST_FREE) CALL MPI_TYPE_FREE(TNO,ERRNO)
      CALL PM__PUSH_MESSAGE(MESS)
   END IF
   IF(PM__BUFFER%SIZEOF(PM__INT32).GT.0) THEN
      CALL PM__GET_MPI_TYPE(MPI_INTEGER4,PM__BUFFER%SIZEOF(PM__INT32),TNO,M,MUST_FREE)
      CALL MPI_ISEND(PM__BUFFER%I32,M,TNO,INT(NODE),TAG,COMM,MESS,ERRNO)
      IF(MUST_FREE) CALL MPI_TYPE_FREE(TNO,ERRNO)
      CALL PM__PUSH_MESSAGE(MESS)
   END IF
     IF(PM__BUFFER%SIZEOF(PM__INT64).GT.0) THEN
      CALL PM__GET_MPI_TYPE(MPI_INTEGER8,PM__BUFFER%SIZEOF(PM__INT64),TNO,M,MUST_FREE)
      CALL MPI_ISEND(PM__BUFFER%I64,M,TNO,INT(NODE),TAG,COMM,MESS,ERRNO)
      IF(MUST_FREE) CALL MPI_TYPE_FREE(TNO,ERRNO)
      CALL PM__PUSH_MESSAGE(MESS)
   END IF
   
   IF(PM__BUFFER%SIZEOF(PM__LONG).GT.0) THEN
      !write(*,*) 'sending',PM__BUFFER%LN,'from',pm__sys_node,'to',node
      CALL PM__GET_MPI_TYPE(MPI_AINT,PM__BUFFER%SIZEOF(PM__LONG),TNO,M,MUST_FREE)
      CALL MPI_ISEND(PM__BUFFER%LN,M,TNO,INT(NODE),TAG,COMM,MESS,ERRNO)
      IF(MUST_FREE) CALL MPI_TYPE_FREE(TNO,ERRNO)
      CALL PM__PUSH_MESSAGE(MESS)
   END IF
   IF(PM__BUFFER%SIZEOF(PM__SINGLE).GT.0) THEN
      CALL PM__GET_MPI_TYPE(MPI_REAL,PM__BUFFER%SIZEOF(PM__SINGLE),TNO,M,MUST_FREE)
      CALL MPI_ISEND(PM__BUFFER%R,M,TNO,INT(NODE),TAG,COMM,MESS,ERRNO)
      IF(MUST_FREE) CALL MPI_TYPE_FREE(TNO,ERRNO)
      CALL PM__PUSH_MESSAGE(MESS)
   END IF
   IF(PM__BUFFER%SIZEOF(PM__DOUBLE).GT.0) THEN
      CALL PM__GET_MPI_TYPE(MPI_DOUBLE,PM__BUFFER%SIZEOF(PM__DOUBLE),TNO,M,MUST_FREE)
      CALL MPI_ISEND(PM__BUFFER%D,M,TNO,INT(NODE),TAG,COMM,MESS,ERRNO)
      IF(MUST_FREE) CALL MPI_TYPE_FREE(TNO,ERRNO)
      CALL PM__PUSH_MESSAGE(MESS)
   END IF
     IF(PM__BUFFER%SIZEOF(PM__SINGLE_COMPLEX).GT.0) THEN
      CALL PM__GET_MPI_TYPE(MPI_COMPLEX,PM__BUFFER%SIZEOF(PM__SINGLE_COMPLEX),TNO,M,MUST_FREE)
      CALL MPI_ISEND(PM__BUFFER%C,M,TNO,INT(NODE),TAG,COMM,MESS,ERRNO)
      IF(MUST_FREE) CALL MPI_TYPE_FREE(TNO,ERRNO)
      CALL PM__PUSH_MESSAGE(MESS)
   END IF
   IF(PM__BUFFER%SIZEOF(PM__DOUBLE_COMPLEX).GT.0) THEN
      CALL PM__GET_MPI_TYPE(MPI_DOUBLE_COMPLEX,PM__BUFFER%SIZEOF(PM__DOUBLE_COMPLEX),TNO,M,MUST_FREE)
      CALL MPI_ISEND(PM__BUFFER%DC,M,TNO,INT(NODE),TAG,COMM,MESS,ERRNO)
      IF(MUST_FREE) CALL MPI_TYPE_FREE(TNO,ERRNO)
      CALL PM__PUSH_MESSAGE(MESS)
   END IF
   IF(PM__BUFFER%SIZEOF(PM__LOGICAL).GT.0) THEN
      CALL PM__GET_MPI_TYPE(MPI_LOGICAL,PM__BUFFER%SIZEOF(PM__LOGICAL),TNO,M,MUST_FREE)
      CALL MPI_ISEND(PM__BUFFER%L,M,TNO,INT(NODE),TAG,COMM,MESS,ERRNO)
      IF(MUST_FREE) CALL MPI_TYPE_FREE(TNO,ERRNO)
      CALL PM__PUSH_MESSAGE(MESS)
   END IF
 END SUBROUTINE PM__ISEND_BUFFER
 
 SUBROUTINE PM__RECV_BUFFER(NODE,ATAG,COMM)
   INTEGER,INTENT(IN):: NODE
   INTEGER,INTENT(IN):: ATAG,COMM
   INTEGER:: MESS,ERRNO,TNO,M,TAG
   LOGICAL:: MUST_FREE
   INTEGER(PM__LN):: SIZEOF(PM__INT:PM__STRING)
   TAG=ATAG+1
   CALL PM__NEW_BUFFER
   CALL MPI_RECV(PM__BUFFER%SIZEOF,PM__STRING-PM__INT+1,MPI_AINT,INT(NODE),TAG,COMM,MPI_STATUS_IGNORE,ERRNO)
   SIZEOF=PM__BUFFER%SIZEOF
   CALL PM__ALLOCATE_BUFFER
   IF(SIZEOF(PM__INT).GT.0) THEN
      CALL PM__GET_MPI_TYPE(MPI_INTEGER,SIZEOF(PM__INT),TNO,M,MUST_FREE)
      CALL MPI_RECV(PM__BUFFER%I,M,TNO,INT(NODE),TAG,COMM,MPI_STATUS_IGNORE,ERRNO)
      IF(MUST_FREE) CALL MPI_TYPE_FREE(TNO,ERRNO)
   END IF
   IF(SIZEOF(PM__INT8).GT.0) THEN
      CALL PM__GET_MPI_TYPE(MPI_INTEGER1,SIZEOF(PM__INT8),TNO,M,MUST_FREE)
      CALL MPI_RECV(PM__BUFFER%I8,M,TNO,INT(NODE),TAG,COMM,MPI_STATUS_IGNORE,ERRNO)
      IF(MUST_FREE) CALL MPI_TYPE_FREE(TNO,ERRNO)
   END IF
   IF(SIZEOF(PM__INT16).GT.0) THEN
      CALL PM__GET_MPI_TYPE(MPI_INTEGER2,SIZEOF(PM__INT16),TNO,M,MUST_FREE)
      CALL MPI_RECV(PM__BUFFER%I16,M,TNO,INT(NODE),TAG,COMM,MPI_STATUS_IGNORE,ERRNO)
      IF(MUST_FREE) CALL MPI_TYPE_FREE(TNO,ERRNO)
   END IF
   IF(SIZEOF(PM__INT32).GT.0) THEN
      CALL PM__GET_MPI_TYPE(MPI_INTEGER4,SIZEOF(PM__INT32),TNO,M,MUST_FREE)
      CALL MPI_RECV(PM__BUFFER%I32,M,TNO,INT(NODE),TAG,COMM,MPI_STATUS_IGNORE,ERRNO)
      IF(MUST_FREE) CALL MPI_TYPE_FREE(TNO,ERRNO)
   END IF
   IF(SIZEOF(PM__INT64).GT.0) THEN
      CALL PM__GET_MPI_TYPE(MPI_INTEGER8,SIZEOF(PM__INT64),TNO,M,MUST_FREE)
      CALL MPI_RECV(PM__BUFFER%I64,M,TNO,INT(NODE),TAG,COMM,MPI_STATUS_IGNORE,ERRNO)
      IF(MUST_FREE) CALL MPI_TYPE_FREE(TNO,ERRNO)
   END IF
   IF(SIZEOF(PM__LONG).GT.0) THEN
      CALL PM__GET_MPI_TYPE(MPI_AINT,SIZEOF(PM__LONG),TNO,M,MUST_FREE)
      CALL MPI_RECV(PM__BUFFER%LN,M,TNO,INT(NODE),TAG,COMM,MPI_STATUS_IGNORE,ERRNO)
      IF(MUST_FREE) CALL MPI_TYPE_FREE(TNO,ERRNO)
   END IF
   IF(SIZEOF(PM__SINGLE).GT.0) THEN
      CALL PM__GET_MPI_TYPE(MPI_REAL,SIZEOF(PM__SINGLE),TNO,M,MUST_FREE)
      CALL MPI_RECV(PM__BUFFER%R,M,TNO,INT(NODE),TAG,COMM,MPI_STATUS_IGNORE,ERRNO)
      IF(MUST_FREE) CALL MPI_TYPE_FREE(TNO,ERRNO)
   END IF
   IF(SIZEOF(PM__DOUBLE).GT.0) THEN
      CALL PM__GET_MPI_TYPE(MPI_DOUBLE,SIZEOF(PM__DOUBLE),TNO,M,MUST_FREE)
      CALL MPI_RECV(PM__BUFFER%D,M,TNO,INT(NODE),TAG,COMM,MPI_STATUS_IGNORE,ERRNO)
      IF(MUST_FREE) CALL MPI_TYPE_FREE(TNO,ERRNO)
   END IF
   IF(SIZEOF(PM__SINGLE_COMPLEX).GT.0) THEN
      CALL PM__GET_MPI_TYPE(MPI_COMPLEX,SIZEOF(PM__SINGLE_COMPLEX),TNO,M,MUST_FREE)
      CALL MPI_RECV(PM__BUFFER%C,M,TNO,INT(NODE),TAG,COMM,MPI_STATUS_IGNORE,ERRNO)
      IF(MUST_FREE) CALL MPI_TYPE_FREE(TNO,ERRNO)
   END IF
   IF(SIZEOF(PM__DOUBLE_COMPLEX).GT.0) THEN
      CALL PM__GET_MPI_TYPE(MPI_DOUBLE_COMPLEX,SIZEOF(PM__DOUBLE_COMPLEX),TNO,M,MUST_FREE)
      CALL MPI_RECV(PM__BUFFER%DC,M,TNO,INT(NODE),TAG,COMM,MPI_STATUS_IGNORE,ERRNO)
      IF(MUST_FREE) CALL MPI_TYPE_FREE(TNO,ERRNO)
   END IF
   IF(SIZEOF(PM__LOGICAL).GT.0) THEN
      CALL PM__GET_MPI_TYPE(MPI_LOGICAL,SIZEOF(PM__LOGICAL),TNO,M,MUST_FREE)
      CALL MPI_RECV(PM__BUFFER%L,M,TNO,INT(NODE),TAG,COMM,MPI_STATUS_IGNORE,ERRNO)
      IF(MUST_FREE) CALL MPI_TYPE_FREE(TNO,ERRNO)
   END IF
   PM__BUFFER%SIZEOF=0
 END SUBROUTINE PM__RECV_BUFFER

 SUBROUTINE PM__BCAST_BUFFER(NODE,XCOMM)
   INTEGER,INTENT(IN):: NODE
   INTEGER,INTENT(IN),OPTIONAL:: XCOMM
   INTEGER:: COMM
   INTEGER:: ERRNO,TNO,M
   LOGICAL:: MUST_FREE
   IF(PRESENT(XCOMM)) THEN
      COMM=XCOMM
   ELSE
      COMM=PM__NODE_FRAME(PM__NODE_DEPTH)%THIS_COMM
   ENDIF
   CALL MPI_BCAST(PM__BUFFER%SIZEOF,PM__STRING-PM__INT+1,MPI_AINT,INT(NODE),COMM,ERRNO)
   IF(PM__BUFFER%SIZEOF(PM__INT).GT.0) THEN
      CALL PM__GET_MPI_TYPE(MPI_INTEGER,PM__BUFFER%SIZEOF(PM__INT),TNO,M,MUST_FREE)
      CALL MPI_BCAST(PM__BUFFER%I,M,TNO,INT(NODE),COMM,ERRNO)
      IF(MUST_FREE) CALL MPI_TYPE_FREE(TNO,ERRNO)
   END IF
   IF(PM__BUFFER%SIZEOF(PM__INT8).GT.0) THEN
      CALL PM__GET_MPI_TYPE(MPI_INTEGER1,PM__BUFFER%SIZEOF(PM__INT8),TNO,M,MUST_FREE)
      CALL MPI_BCAST(PM__BUFFER%I8,M,TNO,INT(NODE),COMM,ERRNO)
      IF(MUST_FREE) CALL MPI_TYPE_FREE(TNO,ERRNO)
   END IF
   IF(PM__BUFFER%SIZEOF(PM__INT16).GT.0) THEN
      CALL PM__GET_MPI_TYPE(MPI_INTEGER2,PM__BUFFER%SIZEOF(PM__INT16),TNO,M,MUST_FREE)
      CALL MPI_BCAST(PM__BUFFER%I16,M,TNO,INT(NODE),COMM,ERRNO)
      IF(MUST_FREE) CALL MPI_TYPE_FREE(TNO,ERRNO)
   END IF
   IF(PM__BUFFER%SIZEOF(PM__INT32).GT.0) THEN
      CALL PM__GET_MPI_TYPE(MPI_INTEGER4,PM__BUFFER%SIZEOF(PM__INT32),TNO,M,MUST_FREE)
      CALL MPI_BCAST(PM__BUFFER%I32,M,TNO,INT(NODE),COMM,ERRNO)
      IF(MUST_FREE) CALL MPI_TYPE_FREE(TNO,ERRNO)
   END IF
   IF(PM__BUFFER%SIZEOF(PM__INT64).GT.0) THEN
      CALL PM__GET_MPI_TYPE(MPI_INTEGER8,PM__BUFFER%SIZEOF(PM__INT64),TNO,M,MUST_FREE)
      CALL MPI_BCAST(PM__BUFFER%I64,M,TNO,INT(NODE),COMM,ERRNO)
      IF(MUST_FREE) CALL MPI_TYPE_FREE(TNO,ERRNO)
   END IF
   IF(PM__BUFFER%SIZEOF(PM__LONG).GT.0) THEN
      CALL PM__GET_MPI_TYPE(MPI_AINT,PM__BUFFER%SIZEOF(PM__LONG),TNO,M,MUST_FREE)
      CALL MPI_BCAST(PM__BUFFER%LN,M,TNO,INT(NODE),COMM,ERRNO)
      IF(MUST_FREE) CALL MPI_TYPE_FREE(TNO,ERRNO)
   END IF
   IF(PM__BUFFER%SIZEOF(PM__SINGLE).GT.0) THEN
      CALL PM__GET_MPI_TYPE(MPI_REAL,PM__BUFFER%SIZEOF(PM__SINGLE),TNO,M,MUST_FREE)
      CALL MPI_BCAST(PM__BUFFER%R,M,TNO,INT(NODE),COMM,ERRNO)
      IF(MUST_FREE) CALL MPI_TYPE_FREE(TNO,ERRNO)
   END IF
   IF(PM__BUFFER%SIZEOF(PM__DOUBLE).GT.0) THEN
      CALL PM__GET_MPI_TYPE(MPI_DOUBLE,PM__BUFFER%SIZEOF(PM__DOUBLE),TNO,M,MUST_FREE)
      CALL MPI_BCAST(PM__BUFFER%D,M,TNO,INT(NODE),COMM,ERRNO)
      IF(MUST_FREE) CALL MPI_TYPE_FREE(TNO,ERRNO)
   END IF
   IF(PM__BUFFER%SIZEOF(PM__SINGLE_COMPLEX).GT.0) THEN
      CALL PM__GET_MPI_TYPE(MPI_COMPLEX,PM__BUFFER%SIZEOF(PM__SINGLE_COMPLEX),TNO,M,MUST_FREE)
      CALL MPI_BCAST(PM__BUFFER%C,M,TNO,INT(NODE),COMM,ERRNO)
      IF(MUST_FREE) CALL MPI_TYPE_FREE(TNO,ERRNO)
   END IF
   IF(PM__BUFFER%SIZEOF(PM__DOUBLE_COMPLEX).GT.0) THEN
      CALL PM__GET_MPI_TYPE(MPI_DOUBLE_COMPLEX,PM__BUFFER%SIZEOF(PM__DOUBLE_COMPLEX),TNO,M,MUST_FREE)
      CALL MPI_BCAST(PM__BUFFER%DC,M,TNO,INT(NODE),COMM,ERRNO)
      IF(MUST_FREE) CALL MPI_TYPE_FREE(TNO,ERRNO)
   END IF
   IF(PM__BUFFER%SIZEOF(PM__LOGICAL).GT.0) THEN
      CALL PM__GET_MPI_TYPE(MPI_LOGICAL,PM__BUFFER%SIZEOF(PM__LOGICAL),TNO,M,MUST_FREE)
      CALL MPI_BCAST(PM__BUFFER%L,M,TNO,INT(NODE),COMM,ERRNO)
      IF(MUST_FREE) CALL MPI_TYPE_FREE(TNO,ERRNO)
   END IF
 END SUBROUTINE PM__BCAST_BUFFER

 FUNCTION PM__TEST_LOOP(OK) RESULT(ALLOK)
   LOGICAL,INTENT(IN):: OK
   LOGICAL:: ALLOK
   CALL MPI_ALLREDUCE(OK,ALLOK,1,MPI_LOGICAL,MPI_LOR,PM__NODE_FRAME(PM__NODE_DEPTH)%THIS_COMM,JERRNO)
 END FUNCTION PM__TEST_LOOP

 SUBROUTINE PM__MASK_OFFSETS(N,OFFSETS,MASK,COUNT)
   INTEGER(PM__LN),INTENT(IN):: N
   INTEGER(PM__LN),INTENT(INOUT),DIMENSION(N):: OFFSETS
   LOGICAL,INTENT(IN),DIMENSION(N):: MASK
   INTEGER(PM__LN),INTENT(OUT):: COUNT
   INTEGER(PM__LN):: I,M
   M=0
   DO I=1,N
      IF(MASK(I)) THEN
         M=M+1
         OFFSETS(M)=OFFSETS(I)
      ENDIF
   ENDDO
   COUNT=M
 END SUBROUTINE PM__MASK_OFFSETS
 
 SUBROUTINE PM__COLLATE_MESSAGES(NODE,ISTART,N,NNODE,START,FROM)
   INTEGER(PM__LN),DIMENSION(*),INTENT(IN):: NODE
   INTEGER(PM__LN),INTENT(IN):: ISTART,N,NNODE
   INTEGER(PM__LN),DIMENSION(0:NNODE),INTENT(INOUT):: START
   INTEGER(PM__LN),DIMENSION(N),INTENT(INOUT):: FROM
   INTEGER(PM__LN):: I,M,TOT
   INTEGER:: P
   START(0:NNODE)=0
   DO I=1,N
      P=NODE(I+ISTART-1)
      START(P)=START(P)+1
   ENDDO
   TOT=1
   DO I=0,NNODE
      M=START(I)
      TOT=TOT+M
      START(I)=TOT
   ENDDO
   DO I=N,1,-1
      P=NODE(I+ISTART-1)
      M=START(P)-1
      FROM(M)=I-1+ISTART-1
      START(P)=M
   ENDDO
 END SUBROUTINE PM__COLLATE_MESSAGES
 
 SUBROUTINE PM__COLLATE_MESSAGES_MASKED(NODE,N,NNODE,START,FROM,VE,BEGIN)
   INTEGER(PM__LN),DIMENSION(*),INTENT(IN):: NODE
   INTEGER(PM__LN),INTENT(IN):: N,NNODE
   INTEGER(PM__LN),DIMENSION(0:NNODE),INTENT(INOUT):: START
   INTEGER(PM__LN),DIMENSION(N),INTENT(INOUT):: FROM
   LOGICAL,DIMENSION(:),INTENT(IN):: VE
   INTEGER(PM__LN),INTENT(INOUT):: BEGIN
   INTEGER(PM__LN):: I,M,TOT,FINISH,COUNT
   INTEGER:: P
   START(0:NNODE)=0
   I=BEGIN
   COUNT=0
   DO WHILE(COUNT<N)
      IF(VE(I)) THEN
         P=NODE(I)
         START(P)=START(P)+1
         COUNT=COUNT+1
      ENDIF
      I=I+1
   ENDDO
   FINISH=I-1
   TOT=1
   DO I=0,NNODE
      M=START(I)
      TOT=TOT+M
      START(I)=TOT
   ENDDO
   DO I=FINISH,1,-1
      IF(VE(I)) THEN
         P=NODE(I)
         M=START(P)-1
         FROM(M)=I-1
         START(P)=M
      ENDIF
   ENDDO
   BEGIN=FINISH
 END SUBROUTINE PM__COLLATE_MESSAGES_MASKED

 SUBROUTINE PM__GET_SHARED_RANKS(RANKS,NUMRANKS)
   INTEGER,ALLOCATABLE,DIMENSION(:),INTENT(INOUT)::RANKS
   INTEGER,INTENT(OUT):: NUMRANKS
   NUMRANKS=0
 END SUBROUTINE PM__GET_SHARED_RANKS
 

 FUNCTION PM__WSHARE(WORK,NNODE,SNODE,NSNODE) RESULT(NODE)
   INTEGER(PM__LN),INTENT(IN):: NNODE,SNODE,NSNODE
   INTEGER(PM__LN),DIMENSION(NNODE):: WORK
   INTEGER(PM__LN):: NODE
   INTEGER(PM__LN):: I,S,Z
   S=SUM(WORK(1:NNODE))
   Z=S*(2_PM__LN*SNODE+1_PM__LN)/(2_PM__LN*NSNODE)
   DO I=1,NNODE
      Z=Z-WORK(I)
      IF(Z<=0) THEN
         NODE=I-1
         RETURN
      ENDIF
   ENDDO
 END FUNCTION PM__WSHARE

 PURE SUBROUTINE PM__INTERSECT_SEQ(L1,U1,S1,N1,L2,U2,S2,N2,L3,U3,S3,N3)
    INTEGER(PM__LN),INTENT(IN):: L1,U1,S1,N1,L2,U2,S2,N2
    INTEGER(PM__LN),INTENT(OUT):: L3,U3,S3,N3
    INTEGER(PM__LN):: C,U,V,G,S,NLO,NHI,UP1,UP2,AS1,AS2,AS3
    !WRITE(*,*) 'INTERSECT_SEQ>',L1,U1,S1,N1,L2,U2,S2,N2
    IF(N1==0.OR.N2==0) THEN
       L3=0
       U3=-1
       S3=1
       N3=0
       RETURN
    ENDIF
    AS1=ABS(S1)
    AS2=ABS(S2)
    C=L1-L2
    CALL PM__EXTENDED_GCD(-AS1,AS2,U,V,G)
    IF(MOD(C,G)/=0) THEN
       L3=0
       U3=-1
       S3=1
       N3=0
       RETURN
    ENDIF
    UP1=L1+(U1-L1)/S1*S1
    UP2=L2+(U2-L2)/S2*S2
    S=C/G*U*S1+L1
    S3=(AS1/ABS(G))*S2
    AS3=ABS(S3)
    NLO=MAX(MIN(L1,UP1),MIN(L2,UP2))-S
    IF(NLO>0) THEN
       NLO=(NLO-1)/AS3+1
    ELSE
       NLO=NLO/AS3
    ENDIF
    NHI=MIN(MAX(L1,UP1),MAX(L2,UP2))-S
    IF(NHI<0) THEN
       NHI=(NHI+1)/AS3-1
    ELSE
       NHI=NHI/AS3
    ENDIF
    L3=S+NLO*AS3
    U3=S+NHI*AS3
    N3=NHI-NLO+1
    IF(S3<0) THEN
       C=U3
       U3=L3
       L3=C
    ENDIF
  END SUBROUTINE PM__INTERSECT_SEQ

  PURE SUBROUTINE PM__EXTENDED_GCD(A,B,U,V,G)
    INTEGER(PM__LN),INTENT(IN):: A,B
    INTEGER(PM__LN),INTENT(OUT):: U,V,G
    INTEGER(PM__LN):: S,OLD_S,R,OLD_R,T,OLD_T,TEMP,Q
    S=0
    OLD_S=1
    T=1
    OLD_T=0
    R=B
    OLD_R=A
    DO WHILE(R/=0)
       Q=OLD_R/R
       TEMP=OLD_R-Q*R
       OLD_R=R
       R=TEMP
       TEMP=OLD_S-Q*S
       OLD_S=S
       S=TEMP
       TEMP=OLD_T-Q*T
       OLD_T=T
       T=TEMP
    ENDDO
    U=OLD_S
    V=OLD_T
    G=OLD_R
  END SUBROUTINE PM__EXTENDED_GCD

  PURE SUBROUTINE PM__INTERSECT_ASEQ(A1,N1,A2,N2,A3,N3)
    INTEGER(PM__LN),DIMENSION(*),INTENT(IN):: A1,A2
    INTEGER(PM__LN),INTENT(IN):: N1,N2
    INTEGER(PM__LN),DIMENSION(*),INTENT(OUT):: A3
    INTEGER(PM__LN),INTENT(OUT):: N3
    INTEGER(PM__LN):: I,J,K
    LOGICAL:: A1ASC,A2ASC
    A1ASC=.TRUE.
    A2ASC=.TRUE.
    IF(N1>1) A1ASC=A1(2)>A1(1)
    IF(N2>1) A2ASC=A2(2)>A2(1)
    IF(A1ASC) THEN
       IF(A2ASC) THEN
          I=1
          J=1
          K=1
          DO WHILE(I<=N1.AND.J<=N2)
             IF(A1(I)<A2(J)) THEN
                I=I+1
             ELSEIF(A1(I)==A2(J)) THEN
                A3(K)=A1(I)
                I=I+1
                J=J+1
                K=K+1
             ELSE
                J=J+1
             ENDIF
          ENDDO
          N3=K-1
       ELSE
          I=N1
          J=1
          K=1
          DO WHILE(I>0.AND.J<=N2)
             IF(A1(I)>A2(J)) THEN
                I=I-1
             ELSEIF(A1(I)==A2(J)) THEN
                A3(K)=A1(I)
                I=I-1
                J=J+1
                K=K+1
             ELSE
                J=J+1
             ENDIF
          ENDDO
          N3=K-1     
       ENDIF
    ELSE
       IF(A2ASC) THEN
          I=N1
          J=1
          K=1
          DO WHILE(I>0.AND.J<=N2)
             IF(A1(I)<A2(J)) THEN
                I=I-1
             ELSEIF(A1(I)==A2(J)) THEN
                A3(K)=A1(I)
                I=I-1
                J=J+1
                K=K+1
             ELSE
                J=J+1
             ENDIF
          ENDDO
          N3=K-1   
       ELSE
          I=1
          J=1
          K=1
          DO WHILE(I<=N1.AND.J<=N2)
             IF(A1(I)>A2(J)) THEN
                I=I+1
             ELSEIF(A1(I)==A2(J)) THEN
                A3(K)=A1(I)
                I=I+1
                J=J+1
                K=K+1
             ELSE
                J=J+1
             ENDIF
          ENDDO
          N3=K-1         
       ENDIF
    ENDIF
  END SUBROUTINE PM__INTERSECT_ASEQ

  FUNCTION PM__ASEQ_INCLUDES(A1,N1,A2,N2) RESULT(OK)
    INTEGER(PM__LN),DIMENSION(*),INTENT(IN):: A1,A2
    INTEGER(PM__LN),INTENT(IN):: N1,N2
    LOGICAL:: OK
    INTEGER(PM__LN):: I,J
    LOGICAL:: A1ASC,A2ASC
    OK=.FALSE.
    IF(N1==0.OR.N2==0) RETURN
    IF(MAX(A1(1),A1(N1)) < MIN(A2(1),A2(N2)).OR.MAX(A2(1),A2(N2)) < MIN(A1(1),A1(N1))) RETURN
    A1ASC=.TRUE.
    A2ASC=.TRUE.
    IF(N1>1) A1ASC=A1(2)>A1(1)
    IF(N2>1) A2ASC=A2(2)>A2(1)
    IF(A1ASC) THEN
       IF(A2ASC) THEN
          I=1
          DO J=1,N2
             DO WHILE(I<=N1.AND.A1(I)<A2(J))
                I=I+1
             ENDDO
             IF(A1(I)/=A2(J)) THEN
                OK=.FALSE.
                RETURN
             ENDIF
          ENDDO
          OK=.TRUE.
          RETURN
       ELSE
          I=1
          DO J=N2,1,-1
             DO WHILE(I<=N1.AND.A1(I)<A2(J))
                I=I+1
             ENDDO
             IF(A1(I)/=A2(J)) THEN
                OK=.FALSE.
                RETURN
             ENDIF
          ENDDO
          OK=.TRUE.
          RETURN
       ENDIF
    ELSE
       IF(A2ASC) THEN
          I=N1
          DO J=1,N2
             DO WHILE(I>0.AND.A1(I)<A2(J))
                I=I-1
             ENDDO
             IF(A1(I)/=A2(J)) THEN
                OK=.FALSE.
                RETURN
             ENDIF
          ENDDO
          OK=.TRUE.
          RETURN
       ELSE
          I=N1
          DO J=N2,1,-1
             DO WHILE(I>0.AND.A1(I)<A2(J))
                I=I-1
             ENDDO
             IF(A1(I)/=A2(J)) THEN
                OK=.FALSE.
                RETURN
             ENDIF
          ENDDO
          OK=.TRUE.
          RETURN
       ENDIF
    ENDIF
  END FUNCTION PM__ASEQ_INCLUDES
  
  PURE SUBROUTINE PM__OVERLAP_ASEQ(A1,N1,A2,N2,A3,N3)
    INTEGER(PM__LN),DIMENSION(*),INTENT(IN):: A1,A2
    INTEGER(PM__LN),INTENT(IN):: N1,N2
    INTEGER(PM__LN),DIMENSION(*),INTENT(OUT):: A3
    INTEGER(PM__LN),INTENT(OUT):: N3
    INTEGER(PM__LN):: I,J,K
    LOGICAL:: A1ASC,A2ASC
    A1ASC=.TRUE.
    A2ASC=.TRUE.
    IF(N1>1) A1ASC=A1(2)>A1(1)
    IF(N2>1) A2ASC=A2(2)>A2(1)
    IF(A1ASC) THEN
       IF(A2ASC) THEN
          I=1
          J=1
          K=1
          DO WHILE(I<=N1.AND.J<=N2)
             IF(A1(I)<A2(J)) THEN
                I=I+1
             ELSEIF(A1(I)==A2(J)) THEN
                A3(K)=I-1
                I=I+1
                J=J+1
                K=K+1
             ELSE
                J=J+1
             ENDIF
          ENDDO
          N3=K-1
       ELSE
          I=N1
          J=1
          K=1
          DO WHILE(I>0.AND.J<=N2)
             IF(A1(I)>A2(J)) THEN
                I=I-1
             ELSEIF(A1(I)==A2(J)) THEN
                A3(K)=I-1
                I=I-1
                J=J+1
                K=K+1
             ELSE
                J=J+1
             ENDIF
          ENDDO
          N3=K-1     
       ENDIF
    ELSE
       IF(A2ASC) THEN
          I=N1
          J=1
          K=1
          DO WHILE(I>0.AND.J<=N2)
             IF(A1(I)<A2(J)) THEN
                I=I-1
             ELSEIF(A1(I)==A2(J)) THEN
                A3(K)=I-1
                I=I-1
                J=J+1
                K=K+1
             ELSE
                J=J+1
             ENDIF
          ENDDO
          N3=K-1   
       ELSE
          I=1
          J=1
          K=1
          DO WHILE(I<=N1.AND.J<=N2)
             IF(A1(I)>A2(J)) THEN
                I=I+1
             ELSEIF(A1(I)==A2(J)) THEN
                A3(K)=I-1
                I=I+1
                J=J+1
                K=K+1
             ELSE
                J=J+1
             ENDIF
          ENDDO
          N3=K-1         
       ENDIF
    ENDIF
  END SUBROUTINE PM__OVERLAP_ASEQ

  PURE SUBROUTINE PM__OVERLAP_ASEQ2(A1,N1,A2,N2,A3,A4,N3)
    INTEGER(PM__LN),DIMENSION(*),INTENT(IN):: A1,A2
    INTEGER(PM__LN),INTENT(IN):: N1,N2
    INTEGER(PM__LN),DIMENSION(*),INTENT(OUT):: A3,A4
    INTEGER(PM__LN),INTENT(OUT):: N3
    INTEGER(PM__LN):: I,J,K
    LOGICAL:: A1ASC,A2ASC
    A1ASC=.TRUE.
    A2ASC=.TRUE.
    IF(N1>1) A1ASC=A1(2)>A1(1)
    IF(N2>1) A2ASC=A2(2)>A2(1)
    IF(A1ASC) THEN
       IF(A2ASC) THEN
          I=1
          J=1
          K=1
          DO WHILE(I<=N1.AND.J<=N2)
             IF(A1(I)<A2(J)) THEN
                I=I+1
             ELSEIF(A1(I)==A2(J)) THEN
                A3(K)=I-1
                A4(K)=J-1
                I=I+1
                J=J+1
                K=K+1
             ELSE
                J=J+1
             ENDIF
          ENDDO
          N3=K-1
       ELSE
          I=N1
          J=1
          K=1
          DO WHILE(I>0.AND.J<=N2)
             IF(A1(I)>A2(J)) THEN
                I=I-1
             ELSEIF(A1(I)==A2(J)) THEN
                A3(K)=I-1
                A4(K)=J-1
                I=I-1
                J=J+1
                K=K+1
             ELSE
                J=J+1
             ENDIF
          ENDDO
          N3=K-1     
       ENDIF
    ELSE
       IF(A2ASC) THEN
          I=N1
          J=1
          K=1
          DO WHILE(I>0.AND.J<=N2)
             IF(A1(I)<A2(J)) THEN
                I=I-1
             ELSEIF(A1(I)==A2(J)) THEN
                A3(K)=I-1
                A4(K)=J-1
                I=I-1
                J=J+1
                K=K+1
             ELSE
                J=J+1
             ENDIF
          ENDDO
          N3=K-1   
       ELSE
          I=1
          J=1
          K=1
          DO WHILE(I<=N1.AND.J<=N2)
             IF(A1(I)>A2(J)) THEN
                I=I+1
             ELSEIF(A1(I)==A2(J)) THEN
                A3(K)=I-1
                A4(K)=J-1
                I=I+1
                J=J+1
                K=K+1
             ELSE
                J=J+1
             ENDIF
          ENDDO
          N3=K-1         
       ENDIF
    ENDIF
  END SUBROUTINE PM__OVERLAP_ASEQ2

  PURE SUBROUTINE PM__INTERSECT_BSEQ(L1,H1,WD1,ST1,AL1,L2,H2,WD2,ST2,AL2,A,N)
    INTEGER(PM__LN),INTENT(IN):: L1,H1,WD1,ST1,AL1,L2,H2,WD2,ST2,AL2
    INTEGER(PM__LN),DIMENSION(*),INTENT(OUT):: A
    INTEGER(PM__LN),INTENT(OUT):: N
    INTEGER(PM__LN):: START,FINISH,ACTUAL_FINISH,FIRST1,LAST1,FIRST2,LAST2
    INTEGER(PM__LN):: W1,W2,I,J,K,KK,BSTART1,BEND1,BSTART2,BEND2,U,V,GCD,JCYCLE

    W1=WD1-1
    W2=WD2-1
    START=MAX(L1,L2)
    ACTUAL_FINISH=MIN(H1,H2)
    IF(ST1==ST2) THEN
       FINISH=MIN(ACTUAL_FINISH,START+ST1-1)
       JCYCLE=ST1
    ELSE
       CALL PM__EXTENDED_GCD(ST1,ST2,U,V,GCD)
       JCYCLE=ST1*ST2/GCD
       FINISH=MIN(ACTUAL_FINISH,START+JCYCLE-1)
    ENDIF
    FIRST1=((START+AL1-L1)/ST1)*ST1+L1-AL1
    FIRST2=((START+AL2-L2)/ST2)*ST2+L2-AL2
    BSTART1=FIRST1+AL1
    BEND1=FIRST1+W1
    BSTART2=FIRST2+AL2
    BEND2=FIRST2+W2
    K=1
    DO I=MAX(BSTART1,BSTART2),MIN(BEND1,BEND2,FINISH)
       A(K)=I
       K=K+1
    END DO
    IF(ST1<=ST2) THEN
       LAST1=((FINISH+AL1-L1)/ST1)*ST1+L1-AL1
       IF(LAST1>FIRST1) THEN
          DO J=FIRST1+ST1,LAST1-1,ST1
             IF(BEND2<J) THEN
                BEND2=BEND2+ST2
             ENDIF
             DO I=MAX(J,BEND2-W2),MIN(J+W1,BEND2)
                A(K)=I
                K=K+1
             END DO
          ENDDO
          J=LAST1
          IF(BEND2<J) THEN
             BEND2=BEND2+ST2
          ENDIF
          DO I=MAX(J,BEND2-W2),MIN(J+W1,BEND2,FINISH)
             A(K)=I
             K=K+1
          ENDDO
       ENDIF
    ELSE
       LAST2=((FINISH+AL2-L2)/ST2)*ST2+L2-AL2
       IF(LAST2>FIRST2) THEN
          DO J=FIRST2+ST2,LAST2-1,ST2
             IF(BEND1<J) THEN
                BEND1=BEND1+ST1
             ENDIF
             DO I=MAX(J,BEND1-W1),MIN(J+W2,BEND1)
                A(K)=I
                K=K+1
             END DO
          ENDDO
          J=LAST2
          IF(BEND1<J) THEN
             BEND1=BEND1+ST1
          ENDIF
          DO I=MAX(J,BEND1-W1),MIN(J+W2,BEND1,FINISH)
             A(K)=I
             K=K+1
          ENDDO
       ENDIF
    ENDIF
    
    KK=K-1
    IF(FINISH<ACTUAL_FINISH.AND.KK>0) THEN
       J=JCYCLE
       DO WHILE(J+A(KK)<=ACTUAL_FINISH)
          DO I=1,KK
             A(K)=A(I)+J
             K=K+1
          ENDDO
          J=J+JCYCLE
       ENDDO
       IF(J+A(1)<=ACTUAL_FINISH) THEN
          I=1
          DO WHILE(A(I)+J<=ACTUAL_FINISH)
             A(K)=A(I)+J
             K=K+1
             I=I+1
          ENDDO
       ENDIF
    ENDIF
    N=K-1
  END SUBROUTINE PM__INTERSECT_BSEQ

  PURE SUBROUTINE PM__OVERLAP_BSEQ(L1,H1,WD1,ST1,AL1,L2,H2,WD2,ST2,AL2,A,N)
    INTEGER(PM__LN),INTENT(IN):: L1,H1,WD1,ST1,AL1,L2,H2,WD2,ST2,AL2
    INTEGER(PM__LN),DIMENSION(*),INTENT(OUT):: A
    INTEGER(PM__LN),INTENT(OUT):: N
    INTEGER(PM__LN):: START,FINISH,ACTUAL_FINISH,FIRST1,LAST1,FIRST2,LAST2
    INTEGER(PM__LN):: W1,W2,I,J,JJ,K,KK,BSTART1,BEND1,BSTART2,BEND2,U,V,GCD,JCYCLE
    INTEGER(PM__LN):: SPAN,NB,JFINISH

    W1=WD1-1
    W2=WD2-1
    START=MAX(L1,L2)
    ACTUAL_FINISH=MIN(H1,H2)
    IF(ST1==ST2) THEN
       FINISH=MIN(ACTUAL_FINISH,START+ST1-1)
       JCYCLE=1
    ELSE
       CALL PM__EXTENDED_GCD(ST1,ST2,U,V,GCD)
       JCYCLE=ST2/GCD
       FINISH=MIN(ACTUAL_FINISH,START+JCYCLE*ST1-1)
    ENDIF
    FIRST1=((START+AL1-L1)/ST1)*ST1+L1-AL1
    FIRST2=((START+AL2-L2)/ST2)*ST2+L2-AL2
    BSTART1=FIRST1+AL1
    BEND1=FIRST1+W1
    BSTART2=FIRST2+AL2
    BEND2=FIRST2+W2
    K=1
    DO I=MAX(BSTART1,BSTART2),MIN(BEND1,BEND2,FINISH)
       A(K)=I-L1
       K=K+1
    END DO
    JJ=WD1-AL1
    IF(ST1<=ST2) THEN
       LAST1=((FINISH+AL1-L1)/ST1)*ST1+L1-AL1
       IF(LAST1>FIRST1) THEN
          DO J=FIRST1+ST1,LAST1-1,ST1
             IF(BEND2<J) THEN
                BEND2=BEND2+ST2
             ENDIF
             DO I=MAX(J,BEND2-W2),MIN(J+W1,BEND2)
                A(K)=I-J+JJ
                K=K+1
             END DO
             JJ=JJ+WD1
          ENDDO
          J=LAST1
          IF(BEND2<J) THEN
             BEND2=BEND2+ST2
          ENDIF
          DO I=MAX(J,BEND2-W2),MIN(J+W1,BEND2,FINISH)
             A(K)=I-J+JJ
             K=K+1
          ENDDO
       ENDIF
    ELSE
       LAST2=((FINISH+AL2-L2)/ST2)*ST2+L2-AL2
       IF(LAST2>FIRST2) THEN
          DO J=FIRST2+ST2,LAST2-1,ST2
             IF(BEND1<J) THEN
                BEND1=BEND1+ST1
                JJ=JJ+WD1
             ENDIF
             DO I=MAX(J,BEND1-W1),MIN(J+W2,BEND1)
                A(K)=I-(BEND1-W1)+JJ
                K=K+1
             END DO
          ENDDO
          J=LAST2
          IF(BEND1<J) THEN
             BEND1=BEND1+ST1
             JJ=JJ+WD1
          ENDIF
          DO I=MAX(J,BEND1-W1),MIN(J+W2,BEND1,FINISH)
             A(K)=I-(BEND1-W1)+JJ
             K=K+1
          ENDDO
       ENDIF
    ENDIF
    
    KK=K-1
    IF(FINISH<ACTUAL_FINISH.AND.KK>0) THEN
       SPAN=ACTUAL_FINISH-L1+AL1
       NB=SPAN/ST1
       JFINISH=MIN(WD1,SPAN-NB*ST1)+NB*WD1-1-AL1
       JCYCLE=JCYCLE*WD1
       J=JCYCLE
       DO WHILE(J+A(KK)<=JFINISH)
          DO I=1,KK
             A(K)=A(I)+J
             K=K+1
          ENDDO
          J=J+JCYCLE
       ENDDO
       IF(J+A(1)<=JFINISH) THEN
          I=1
          DO WHILE(A(I)+J<=JFINISH)
             A(K)=A(I)+J
             K=K+1
             I=I+1
          ENDDO
       ENDIF
    ENDIF
    N=K-1
  END SUBROUTINE PM__OVERLAP_BSEQ

  PURE SUBROUTINE PM__OVERLAP_BSEQ2(L1,H1,WD1,ST1,AL1,L2,H2,WD2,ST2,AL2,A1,A2,N)
    INTEGER(PM__LN),INTENT(IN):: L1,H1,WD1,ST1,AL1,L2,H2,WD2,ST2,AL2
    INTEGER(PM__LN),DIMENSION(*),INTENT(OUT):: A1,A2
    INTEGER(PM__LN),INTENT(OUT):: N
    INTEGER(PM__LN):: START,FINISH,ACTUAL_FINISH,FIRST1,LAST1,FIRST2,LAST2
    INTEGER(PM__LN):: W1,W2,I,J,JJ1,JJ2,K,KK,BSTART1,BEND1,BSTART2,BEND2,U,V,GCD,JCYCLE
    INTEGER(PM__LN):: SPAN,NB,JFINISH

    W1=WD1-1
    W2=WD2-1
    START=MAX(L1,L2)
    ACTUAL_FINISH=MIN(H1,H2)
    IF(ST1==ST2) THEN
       FINISH=MIN(ACTUAL_FINISH,START+ST1-1)
       GCD=ST1
    ELSE
       CALL PM__EXTENDED_GCD(ST1,ST2,U,V,GCD)
       FINISH=MIN(ACTUAL_FINISH,START+ST1*ST2/GCD-1)
    ENDIF
    FIRST1=((START+AL1-L1)/ST1)*ST1+L1-AL1
    FIRST2=((START+AL2-L2)/ST2)*ST2+L2-AL2
    BSTART1=FIRST1+AL1
    BEND1=FIRST1+W1
    BSTART2=FIRST2+AL2
    BEND2=FIRST2+W2
    K=1
    DO I=MAX(BSTART1,BSTART2),MIN(BEND1,BEND2,FINISH)
       A1(K)=I-L1
       A2(K)=I-L2
       K=K+1
    END DO
    JJ1=WD1-AL1
    JJ2=-AL2
    IF(ST1<=ST2) THEN
       LAST1=((FINISH+AL1-L1)/ST1)*ST1+L1-AL1
       IF(LAST1>FIRST1) THEN
          DO J=FIRST1+ST1,LAST1-1,ST1
             IF(BEND2<J) THEN
                BEND2=BEND2+ST2
                JJ2=JJ2+WD2
             ENDIF
             DO I=MAX(J,BEND2-W2),MIN(J+W1,BEND2)
                A1(K)=I-J+JJ1
                A2(K)=I-(BEND2-W2)+JJ2
                K=K+1
             END DO
             JJ1=JJ1+WD1
          ENDDO
          J=LAST1
          IF(BEND2<J) THEN
             BEND2=BEND2+ST2
             JJ2=JJ2+WD2
          ENDIF
          DO I=MAX(J,BEND2-W2),MIN(J+W1,BEND2,FINISH)
             A1(K)=I-J+JJ1
             A2(K)=I-(BEND2-W2)+JJ2
             K=K+1
          ENDDO
       ENDIF
    ELSE
       LAST2=((FINISH+AL2-L2)/ST2)*ST2+L2-AL2
       IF(LAST2>FIRST2) THEN
          DO J=FIRST2+ST2,LAST2-1,ST2
             JJ2=JJ2+WD2
             IF(BEND1<J) THEN
                BEND1=BEND1+ST1
                JJ1=JJ1+WD1
             ENDIF
             DO I=MAX(J,BEND1-W1),MIN(J+W2,BEND1)
                A1(K)=I-(BEND1-W1)+JJ1
                A2(K)=I-J+JJ2
                K=K+1
                JJ2=JJ2+WD2
             END DO
          ENDDO
          J=LAST2
          IF(BEND1<J) THEN
             BEND1=BEND1+ST1
             JJ1=JJ1+WD1
          ENDIF
          DO I=MAX(J,BEND1-W1),MIN(J+W2,BEND1,FINISH)
             A1(K)=I-(BEND1-W1)+JJ1
             A2(K)=I-J+JJ2
             K=K+1
          ENDDO
       ENDIF
    ENDIF
    
    KK=K-1
    IF(FINISH<ACTUAL_FINISH.AND.KK>0) THEN
       SPAN=ACTUAL_FINISH-L1+AL1
       NB=SPAN/ST1
       JFINISH=MIN(WD1,SPAN-NB*ST1)+NB*WD1-1-AL1
       JCYCLE=WD1*ST2/GCD
       J=JCYCLE
       DO WHILE(J+A1(KK)<=JFINISH)
          DO I=1,KK
             A1(K)=A1(I)+J
             K=K+1
          ENDDO
          J=J+JCYCLE
       ENDDO
       IF(J+A1(1)<=JFINISH) THEN
          I=1
          DO WHILE(A1(I)+J<=JFINISH)
             A1(K)=A1(I)+J
             K=K+1
             I=I+1
          ENDDO
       ENDIF
       K=KK+1
       SPAN=ACTUAL_FINISH-L2+AL2
       NB=SPAN/ST2
       JFINISH=MIN(WD2,SPAN-NB*ST2)+NB*WD2-1-AL2
       JCYCLE=ST1*WD2/GCD
       J=JCYCLE
       DO WHILE(J+A2(KK)<=JFINISH)
          DO I=1,KK
             A2(K)=A2(I)+J
             K=K+1
          ENDDO
          J=J+JCYCLE
       ENDDO
       IF(J+A2(1)<=JFINISH) THEN
          I=1
          DO WHILE(A2(I)+J<=JFINISH)
             A2(K)=A2(I)+J
             K=K+1
             I=I+1
          ENDDO
       ENDIF
    ENDIF
    
    N=K-1
  END SUBROUTINE PM__OVERLAP_BSEQ2
  
  PURE SUBROUTINE PM__EXPAND_ASEQ(A1,N1,LO,HI,A2,N2)
    INTEGER(PM__LN),DIMENSION(*),INTENT(IN):: A1
    INTEGER(PM__LN),INTENT(IN):: N1,LO,HI
    INTEGER(PM__LN),DIMENSION(*),INTENT(OUT):: A2
    INTEGER(PM__LN),INTENT(OUT):: N2
    INTEGER(PM__LN):: I,J,K,M,S
    IF(N1==0) THEN
       N2=0
       RETURN
    ELSEIF(N1==1) THEN
       K=1
       DO I=A1(1)+LO,A1(1)+HI
          A2(K)=I
          K=K+1
       ENDDO
    ELSEIF(HI-LO>0) THEN
       K=1
       IF(A1(1)<A1(2)) THEN
          DO I=1,N1-1
             DO J=A1(I)+LO,MIN(A1(I)+HI,A1(I+1)+LO-1)
                A2(K)=J
                K=K+1
             ENDDO
          ENDDO
          DO J=A1(N1)+LO,A1(N1)+HI
             A2(K)=J
             K=K+1
          ENDDO
       ELSE
          DO I=1,N1-1
             DO J=A1(I)+HI,MAX(A1(I)+LO,A1(I+1)+HI+1),-1
                A2(K)=J
                K=K+1
             ENDDO
          ENDDO
          DO J=A1(N1)+HI,A1(N1)+LO,-1
             A2(K)=J
             K=K+1
          ENDDO
       ENDIF
    ELSE
       J=1
       K=1
       DO WHILE(J<N1)
          M=0
          S=A1(J)
          DO WHILE(A1(J+1)==A1(J)+1)
             M=M+1
             J=J+1
             IF(J==N1) EXIT
          ENDDO
          DO I=S+LO,S+M+HI
             A2(K)=I
             K=K+1
          ENDDO
          J=J+1
       ENDDO
    ENDIF
    N2=K-1
  END SUBROUTINE PM__EXPAND_ASEQ

  FUNCTION PM__ASEQ_INDEX(A,N,V) RESULT(INDEX)
    INTEGER(PM__LN),DIMENSION(*),INTENT(IN):: A
    INTEGER(PM__LN),INTENT(IN):: N
    INTEGER(PM__LN),INTENT(IN):: V
    INTEGER(PM__LN):: INDEX
    INTEGER(PM__LN):: LEFT,RIGHT,MIDDLE
    LEFT=1
    RIGHT=N+1
    IF(A(1)<A(2)) THEN
       IF(V<A(1)) THEN
          INDEX=-1
       ENDIF
       DO WHILE(LEFT<RIGHT-1)
          MIDDLE=(LEFT+RIGHT)/2
          IF(A(MIDDLE)<=V) THEN
             LEFT=MIDDLE
          ELSE
             RIGHT=MIDDLE
          ENDIF
       ENDDO
       INDEX=LEFT-1
    ELSE
       IF(V<A(N)) THEN
          INDEX=N
          RETURN
       ENDIF
       DO WHILE(LEFT<RIGHT-1)
          MIDDLE=(LEFT+RIGHT)/2
          IF(A(MIDDLE)>V) THEN
             LEFT=MIDDLE
          ELSE
             RIGHT=MIDDLE
          ENDIF
       ENDDO
       INDEX=RIGHT-1
    ENDIF
  END FUNCTION PM__ASEQ_INDEX

  FUNCTION PM__FILE_OPEN(NAME,APPEND,CREATE,TEMP,EXCL,READABLE,&
       WRITEABLE,SEQUENTIAL,IERR) RESULT(HANDLE)
    CHARACTER(LEN=1),DIMENSION(:),INTENT(IN)::NAME
    LOGICAL,INTENT(IN):: APPEND,CREATE,TEMP,EXCL,READABLE,&
         WRITEABLE,SEQUENTIAL
    INTEGER,INTENT(OUT):: IERR
    INTEGER:: HANDLE
    INTEGER:: MODE,I
    CHARACTER(LEN=PM__MAX_FILENAME_SIZE):: FNAME
    MODE=0
    IF(APPEND) MODE=IOR(MODE,MPI_MODE_APPEND)
    IF(CREATE) MODE=IOR(MODE,MPI_MODE_CREATE)
    IF(EXCL) MODE=IOR(MODE,MPI_MODE_EXCL)
    IF(TEMP)   MODE=IOR(MODE,MPI_MODE_DELETE_ON_CLOSE)
    IF(SEQUENTIAL) MODE=IOR(MODE,MPI_MODE_SEQUENTIAL)
    IF(READABLE.AND.WRITEABLE) THEN
       MODE=IOR(MODE,MPI_MODE_RDWR)
    ELSEIF(.NOT.(READABLE.OR.WRITEABLE)) THEN
       IF(SEQUENTIAL) THEN
          MODE=IOR(MODE,MPI_MODE_RDONLY)
       ELSE
          MODE=IOR(MODE,MPI_MODE_RDWR)
       ENDIF
    ELSE
       IF(READABLE) MODE=IOR(MODE,MPI_MODE_RDONLY)
       IF(WRITEABLE) MODE=IOR(MODE,MPI_MODE_WRONLY)
    ENDIF
    FNAME=' '
    DO I=1,MIN(SIZE(NAME),PM__MAX_FILENAME_SIZE)
       FNAME(I:I)=NAME(I)
    ENDDO
    CALL MPI_FILE_OPEN(PM__NODE_FRAME(PM__NODE_DEPTH)%SHARED_COMM,TRIM(FNAME),&
         MODE,MPI_INFO_NULL,HANDLE,IERR)
  END FUNCTION PM__FILE_OPEN

  SUBROUTINE PM__SYNC_FILE_WRITE(IFILE,IERR)
    INTEGER,INTENT(INOUT):: IFILE,IERR
    INTEGER(MPI_OFFSET_KIND),DIMENSION(2):: MESS
    INTEGER(MPI_OFFSET_KIND):: OFFSET
    IF(PM__NODE_FRAME(PM__NODE_DEPTH)%SHARED_NODE==0) THEN
       CALL MPI_FILE_GET_POSITION(IFILE,OFFSET,JERRNO)
       MESS(1)=IERR
       MESS(2)=OFFSET
       CALL MPI_BCAST(MESS,2,MPI_OFFSET,0,PM__NODE_FRAME(PM__NODE_DEPTH)%SHARED_COMM,JERRNO)
    ELSE
       CALL MPI_BCAST(MESS,2,MPI_OFFSET,0,PM__NODE_FRAME(PM__NODE_DEPTH)%SHARED_COMM,JERRNO)
       IERR=MESS(1)
       IF(IERR==0) CALL MPI_FILE_SEEK(IFILE,MESS(2),MPI_SEEK_SET,JERRNO)
    ENDIF
  END SUBROUTINE PM__SYNC_FILE_WRITE

  SUBROUTINE PM__FILE_SET_VIEW(IFILE,ITYPE,OFFSETS,NOFF,TOTSIZE,IERR,DISP)
    INTEGER,INTENT(IN):: IFILE,ITYPE
    INTEGER(PM__LN),INTENT(IN):: NOFF,TOTSIZE
    INTEGER(PM__LN),DIMENSION(NOFF),INTENT(IN):: OFFSETS
    INTEGER,INTENT(INOUT):: IERR
    INTEGER(MPI_OFFSET_KIND),INTENT(OUT):: DISP
    INTEGER:: SIZE,CTYPE,MTYPE
    CALL MPI_TYPE_SIZE(ITYPE,SIZE,IERR)
    CALL MPI_FILE_GET_POSITION(IFILE,DISP,IERR)
    IF(IERR/=MPI_SUCCESS) RETURN
    CALL PM__GET_MPI_DISP_TYPE(ITYPE,OFFSETS,1_PM__LN,CTYPE)
    CALL MPI_TYPE_CREATE_RESIZED(CTYPE,0_PM__LN,TOTSIZE*SIZE,MTYPE,IERR)
    CALL MPI_FILE_SET_VIEW(IFILE,DISP,ITYPE,MTYPE,'NATIVE',MPI_INFO_NULL,IERR)
    DISP=DISP+TOTSIZE*SIZE
  END SUBROUTINE PM__FILE_SET_VIEW

  SUBROUTINE PM__FILE_RESET_VIEW(IFILE,DISP,IERR)
    INTEGER,INTENT(IN):: IFILE
    INTEGER(MPI_OFFSET_KIND),INTENT(IN):: DISP
    INTEGER,INTENT(INOUT):: IERR
    CALL MPI_FILE_SET_VIEW(IFILE,0_PM__LN,MPI_BYTE,MPI_BYTE,'NATIVE',MPI_INFO_NULL,IERR)
    IF(IERR/=MPI_SUCCESS) RETURN
    CALL MPI_FILE_SEEK(IFILE,DISP,MPI_SEEK_SET,IERR)
  END SUBROUTINE PM__FILE_RESET_VIEW

  ! GET CARTESIAN DIMENSIONS 
  SUBROUTINE PM__GET_DIMS(SHARED_NNODE,NDIMS,DIMS)
    INTEGER,INTENT(IN):: NDIMS
    INTEGER,DIMENSION(NDIMS),INTENT(INOUT):: DIMS
    INTEGER,INTENT(IN):: SHARED_NNODE
    INTEGER:: NNODES,ERROR,I,J,NREQUIRED
    LOGICAL:: HAS_ZERO
    DO I=1,NDIMS
       IF(DIMS(I)<0) THEN
          DIMS=1
          DIMS(1)=HUGE(1)
          RETURN
       ENDIF
    ENDDO
    IF(SHARED_NNODE>1) THEN
       NREQUIRED=1
       HAS_ZERO=.TRUE.
       DO I=1,NDIMS
          IF(DIMS(I)/=0) THEN
             NREQUIRED=NREQUIRED*DIMS(I)
          ELSE
             HAS_ZERO=.TRUE.
          ENDIF
       ENDDO
       IF(NREQUIRED>=SHARED_NNODE) THEN
          IF(HAS_ZERO) THEN
             DO I=1,NDIMS
                IF(DIMS(I)==0) DIMS(I)=1
             ENDDO
          ENDIF
       ELSEIF(HAS_ZERO) THEN
          NNODES=(SHARED_NNODE/NREQUIRED)*NREQUIRED
          CALL MPI_DIMS_CREATE(NNODES,NDIMS,DIMS,ERROR)
       ENDIF
    ELSE
       DIMS=1
    ENDIF
  END SUBROUTINE PM__GET_DIMS

  FUNCTION PM__IO_ERROR_STRING(N) RESULT(S)
    INTEGER,INTENT(IN):: N
    TYPE(PM__STR):: S
    CHARACTER(LEN=MPI_MAX_ERROR_STRING):: MESS
    INTEGER:: LENGTH,IERR
    CALL MPI_ERROR_STRING(N,MESS,LENGTH,IERR)
    S=PM__STRVAL(TRIM(MESS(INDEX(MESS,':')+1:)))
  END FUNCTION PM__IO_ERROR_STRING

  SUBROUTINE PM__ABORT(S)
    TYPE(PM__STR):: S
    INTEGER:: IERR
    WRITE(*,*) '====  RUNTIME ERROR ===='
    CALL PM__PRINT(S)
    CALL MPI_ABORT(MPI_COMM_WORLD,1,IERR)
  END SUBROUTINE PM__ABORT
